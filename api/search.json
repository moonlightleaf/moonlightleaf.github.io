[{"id":"70154bdd37d99837a150483aa899c737","title":"Mudong-EV : A multi-threaded network library in C++20","content":"Mudong-EV : A multi-threaded network library in C++20代码仓库https://github.com/moonlightleaf/mudong-ev\n项目简介mudong-ev是一款基于C++20开发的适用于Linux的事件驱动型多线程网络库，附带有日志、定时器、线程池模块，只依赖STL，无第三方依赖。日志模块使用了C++20标准库中的format来进行格式化输出，也是整个项目唯一依赖C++20的模块，其余部分均依赖于C++11实现。参考陈硕的muduo网络库，基于one loop per thread搭配线程池的方式实现multi-reactor架构。\n开发环境\n\n\nTool\nVersion\n\n\n\nUbuntu(WSL2)\n20.04\n\n\nGCC\n13.1.0\n\n\nCmake\n3.23.0\n\n\nGit\n2.25.1\n\n\n项目架构\nmudong-ev的核心架构如上图所示，服务端为一个TcpServer实例，该实例中可包含有多个TcpServerSingle实例，每个TcpServerSingle实例都对应有一个EventLoop，运行在一个独立线程中。每个TcpServerSingle都包含有独立的Acceptor负责监听服务器端口并在连接到来时通过调用newConnectionCallback来对连接事件进行处理。该回调函数由TcpServerSingle传入Acceptor，负责建立连接对象TcpConnection。当客户端连接请求到来时，若有多个Acceptor监听同一个服务器端口（已开启SO_REUSEPORT选项），则由操作系统采用相对公平的方式决定将连接分配给哪个线程，从而实现负载均衡。\n使用示例项目代码仓库中的examples文件夹下，有EchoServer和AddOneServer两个示例，并给出了相应的客户端代码。先运行服务端程序，可以在标准输出流中观察到Log的输出（也可以自定义使得Log输出到指定文件）。之后运行客户端代码，并输入合法的字符串即可收到服务端的返回值。AddOneServer操作示例，以两个客户端为例：\naddOne_client 0 :\n# input\n123\n# server return\nConnection handled by tid 27793, \ncalculation handled by tid 27758: 124\n\naddOne_client 1 :\n# input\n234\n# server return\nConnection handled by tid 27800, \ncalculation handled by tid 27759: 235\n\naddOne_server :\n# log\n20231007 13:41:11.610 [27757] [  INFO] create TcpServer 0.0.0.0:9877 - TcpServer.cc:16\n20231007 13:41:11.611 [27757] [  INFO] TcpServer::start() 0.0.0.0:9877 with 32 eventLoop thread(s) - TcpServer.cc:62\n20231007 13:41:16.527 [27757] [  INFO] connection 127.0.0.1:60642 -&gt; 0.0.0.0:9877 is up - AddOneServer.cc:42\n20231007 13:41:19.816 [27757] [ TRACE] connection 127.0.0.1:60642 -&gt; 0.0.0.0:9877 recv 3 byte(s) - AddOneServer.cc:51\n20231007 13:41:23.760 [27757] [  INFO] connection 127.0.0.1:60644 -&gt; 0.0.0.0:9877 is up - AddOneServer.cc:42\n20231007 13:41:26.212 [27757] [ TRACE] connection 127.0.0.1:60644 -&gt; 0.0.0.0:9877 recv 3 byte(s) - AddOneServer.cc:51\n20231007 13:41:35.721 [27757] [  INFO] connection 127.0.0.1:60644 -&gt; 0.0.0.0:9877 is down - AddOneServer.cc:42\n20231007 13:41:38.072 [27757] [  INFO] connection 127.0.0.1:60642 -&gt; 0.0.0.0:9877 is down - AddOneServer.cc:42\n20231007 13:42:11.616 [27757] [  INFO] server quit after 5 second(s)... - AddOneServer.cc:123\n20231007 13:42:12.616 [27757] [  INFO] server quit after 4 second(s)... - AddOneServer.cc:125\n20231007 13:42:13.616 [27757] [  INFO] server quit after 3 second(s)... - AddOneServer.cc:125\n20231007 13:42:14.616 [27757] [  INFO] server quit after 2 second(s)... - AddOneServer.cc:125\n20231007 13:42:15.616 [27757] [  INFO] server quit after 1 second(s)... - AddOneServer.cc:125\n20231007 13:42:16.616 [27757] [  INFO] server quit after 0 second(s)... - AddOneServer.cc:125\n\nAddOneServer采用multi-reactor接受连接请求，线程池处理计算任务的架构，从客户端得到的返回结果可以看出，两个客户端的连接请求分别由不同的线程接受，两个客户端的计算任务也由线程池中两个不同的线程执行。\n测试&amp;&amp;性能使用JMeter对示例中的AddOneServer进行压测，TPS可上万。\n编译&amp;&amp;使用$ git clone https:&#x2F;&#x2F;github.com&#x2F;moonlightleaf&#x2F;mudong-ev.git\n$ cd mudong-ev\n$ mkdir build &amp;&amp; cd build\n$ cmake [-DCMAKE_BUILD_TESTS&#x3D;1] [-DCMAKE_BUILD_EXAMPLES&#x3D;1] ..\n$ make install\n\n可以通过选择是否添加-DCMAKE_BUILD_TESTS=1和-DCMAKE_BUILD_EXAMPLES=1选项，来决定是否要对test和examples目录下的文件进行编译。\n参考\nmuduo: Event-driven network library for multi-threaded Linux server in C++11\n\n","slug":"Mudong-EV","date":"2023-10-07T14:29:12.000Z","categories_index":"项目记录","tags_index":"项目记录","author_index":"月下叶子"},{"id":"807cb41303b26161ae1be698fadf9a17","title":"Mudong-JSON : A JSON parser/generator in C++17","content":"Mudong-JSON : A JSON parser&#x2F;generator in C++17\n代码仓库https://github.com/moonlightleaf/mudong-json\n项目简介mudong-json是一款基于C++17开发的header-only JSON解析&#x2F;生成器，采用递归下降的方式进行解析，支持DOM(Document Object Model) 和SAX(Simple API for XML) 两种API风格:\n\nDOM是一种基于树状结构的JSON解析模型。在DOM解析中，整个JSON文件被加载到内存中并表示为一个树状结构的对象模型，JSON中的每个元素都对应一个节点，这些节点可以通过编程接口进行访问、遍历和修改。DOM解析允许应用程序以树状结构的方式直接操作JSON数据，但可能需要更多的内存和计算资源，尤其是对于大型文档。DOM的优点是易于编写代码和操作，特别适用于需要频繁随机访问JSON数据的情况。\nSAX是一种基于事件的JSON解析模型。在SAX解析中，JSON文档被顺序解析，当解析器遇到特定的JSON元素或事件（如开始标签、结束标签、文本内容等）时，它会触发相应的事件，从而允许应用程序在处理过程中做出响应。SAX解析器一次只解析文档的一部分，因此适用于处理大型JSON文档，因为它不需要将整个文档加载到内存中。SAX的优点是效率高，占用的内存少，但在代码编写上通常需要更多的处理逻辑。\n\n以如下JSON字符串为例：\n&#123;\n    &quot;hello&quot;: &quot;world&quot;,\n    &quot;t&quot;: true ,\n    &quot;f&quot;: false,\n    &quot;n&quot;: null,\n    &quot;i&quot;: 123,\n    &quot;pi&quot;: 3.1416,\n    &quot;a&quot;: [1, 2, 3, 4]\n&#125;\n其DOM树构建为：\n\n  \n  DOM树\n\n\n本项目的开发和测试环境为：Ubuntu 20.04 (WSL2)、gcc 9.4.0 -std&#x3D;c++17、cmake 3.16.3。\n项目架构mudong-json定义有三个核心concept，分别是ReadStream、WriteStream和Handler:\n\nReadStream用于读取字符流，目前实现了StringReadStream和FileReadStream分别用于从内存和文件中读取字符。\nWriteStream用于输出字符流，目前实现了StringWriteStream和FileWriteStream分别用于向内存和文件中输出字符。\nHandler是解析和生成时，用于事件触发和执行的对象，目前实现了SAX风格的Writer用于向WriteStream输出字符，以及DOM风格的Document用于构建JSON对象的树形存储结构。\n\n其中，ReadStream和WriteStream的实现只能为StringXXX和FileXXX，通过enable_if_t进行编译期模板参数类型检查；Handler除现有实现外，支持自定义，以进行定制化操作。\n\n  \n  架构UML类图\n\n\n关系的核心是Handler概念。在SAX一边，Reader从流解析JSON并将事件发送到Handler。Writer实现了Handler概念，用于处理相同的事件。在DOM一边，Document实现了Handler概念，用于通过这些事件来构建DOM。在这个设计，SAX是不依赖于DOM的。甚至Reader和Writer之间也没有依赖。这提供了连接事件发送器和处理器的灵活性。除此之外，Value也是不依赖于SAX的。所以，除了将DOM序列化为JSON之外，用户也可以将其序列化为XML，或者做任何其他事情。\n值（Value）mudong-json中自定义了可变类型数据存储类Value，其设计类似于QT中的QVariant和C++17中的Variant，json文档中的每一个元素（DOM树状结构上的叶子节点或子树）都可以用Value来存储，是DOM API的核心。其内部维护一个union来存储数据并节约存储空间：\nunion &#123;\n    bool                b_;\n    int32_t             i32_;\n    int64_t             i64_;\n    double              d_;\n    StringWithRefCount* s_;\n    ArrayWithRefCount*  a_;\n    ObjectWithRefCount* o_;\n&#125;;\n并使用enum class定义了ValueType来表示当前Value的类型，防止命名空间污染：\nenum class ValueType &#123;\n    TYPE_NULL,\n    TYPE_BOOL,\n    TYPE_INT32,\n    TYPE_INT64,\n    TYPE_DOUBLE,\n    TYPE_STRING,\n    TYPE_ARRAY,\n    TYPE_OBJECT\n&#125;;\nValue内部定义了**isXXX()、getXXX()和setXXX([args])**，分别用来判断类型、访问成员和修改成员（XXX可为Null、Bool、Int32、Int64、Double、String、Array和Object）。其中getXXX()中对类型断言判断以进行类型检查，若Value本身类型与getXXX()类型不一致，在Debug模式下将因断言失败而崩溃。\n使用示例1. 读写JSONDOM风格API使用示例如下：\n#include &lt;Document.hpp&gt;\n\n#include &lt;iostream&gt;\n\nint main() &#123;\n    json::Document doc;\n    auto err &#x3D; doc.parse(&quot;&#123;&quot;\n    &quot;    \\&quot;precision\\&quot;: \\&quot;zip\\&quot;,&quot;\n    &quot;    \\&quot;Latitude\\&quot;: 37.766800000000003,&quot;\n    &quot;    \\&quot;Longitude\\&quot;: -122.3959,&quot;\n    &quot;    \\&quot;Address\\&quot;: \\&quot;\\&quot;,&quot;\n    &quot;    \\&quot;City\\&quot;: \\&quot;SAN FRANCISCO\\&quot;,&quot;\n    &quot;    \\&quot;State\\&quot;: \\&quot;CA\\&quot;,&quot;\n    &quot;    \\&quot;Zip\\&quot;: \\&quot;94107\\&quot;,&quot;\n    &quot;    \\&quot;Country\\&quot;: \\&quot;US\\&quot;&quot;\n    &quot;    &#125;&quot;);\n\n    if (err !&#x3D; json::ParseError::PARSE_OK) &#123;\n        std::cerr &lt;&lt; json::parseErrorStr(err) &lt;&lt; std::endl;\n        exit(1);\n    &#125;\n\n    &#x2F;&#x2F;get &quot;Country&quot; field\n    &#x2F;&#x2F;使用operator[](const std::string_view&amp;)必须确保doc树中必须包含&quot;Country&quot;的成员，否则将断言失败\n    json::Value&amp; country &#x3D; doc[&quot;Country&quot;];\n    std::cout &lt;&lt; country.getStringView() &lt;&lt; std::endl;\n    &#x2F;&#x2F;更安全的做法是使用Document.findMember(const std::string_view&amp; key)\n    json::Value::MemberIterator countryIter &#x3D; doc.findMember(&quot;Country&quot;);\n    if (countryIter !&#x3D; doc.endMember()) &#123;\n        std::cout &lt;&lt; countryIter-&gt;value.getStringView() &lt;&lt; std::endl;\n    &#125;\n\n    &#x2F;&#x2F;set &quot;Address&quot;\n    json::Value&amp; addr &#x3D; doc[&quot;Address&quot;];\n    addr.setString(&quot;Block 1, Street 2&quot;);\n    std::cout &lt;&lt; addr.getStringView() &lt;&lt; std::endl;\n&#125;\n输出\nUS\nUS\nBlock 1, Street 2\nDocument继承自Value，即Document是一个Value，可以使用isXXX()、getXXX()和setXXX([args])来进行操作和判断。对于json::ValueType::TYPE_ARRAY类型的Value，可以使用**operator[](const std::string_view&amp;)便捷地访问或修改Value的成员，但调用方必须确保想要获取的成员确切存在。倘若不确定，更安全的做法是使用Document.findMember(const std::string_view&amp; key)，来根据key查找指向该key所对应value的迭代器，倘若不为Document.endMember()**则说明存在，并可通过返回的迭代器访问和修改value。对于小型的JSON文档，使用DOM风格的API更加方便和简洁。\nSAX风格API使用示例如下：\n#include &lt;FileReadStream.hpp&gt;\n#include &lt;FileWriteStream.hpp&gt;\n#include &lt;Writer.hpp&gt;\n#include &lt;Reader.hpp&gt;\n#include &lt;noncopyable.hpp&gt;\n#include &lt;Exception.hpp&gt;\n\n#include &lt;iostream&gt;\n\ntemplate&lt;typename Handler&gt;\nclass AddOne: json::noncopyable &#123;\npublic:\n    bool Null()                &#123; return handler_.Null(); &#125;\n    bool Bool(bool b)          &#123; return handler_.Bool(b); &#125;\n    bool Int32(int32_t i32)    &#123; return handler_.Int32(i32 + 1); &#125; &#x2F;&#x2F; add one\n    bool Int64(int64_t i64)    &#123; return handler_.Int64(i64 + 1); &#125; &#x2F;&#x2F; add one\n    bool Double(double d)      &#123; return handler_.Double(d + 1); &#125;  &#x2F;&#x2F; add one\n    bool String(std::string_view s) &#123; return handler_.String(s); &#125;\n    bool StartObject()         &#123; return handler_.StartObject(); &#125;\n    bool Key(std::string_view s)    &#123; return handler_.Key(s); &#125;\n    bool EndObject()           &#123; return handler_.EndObject(); &#125;\n    bool StartArray()          &#123; return handler_.StartArray(); &#125;\n    bool EndArray()            &#123; return handler_.EndArray(); &#125;\n\n    explicit AddOne(Handler&amp; handler): handler_(handler) &#123; &#125;\n\nprivate:\n    Handler&amp; handler_;\n&#125;;\n\nint main() &#123;\n    json::FileReadStream is(stdin);\n    json::FileWriteStream os(stdout);\n    json::Writer writer(os);\n    AddOne addOne(writer);\n\n    json::ParseError err &#x3D; json::Reader::parse(is, addOne);\n    if (err !&#x3D; json::ParseError::PARSE_OK) &#123;\n        std::cerr &lt;&lt; json::parseErrorStr(err) &lt;&lt; std::endl;\n        exit(1);\n    &#125;\n&#125;\nstdin输入：\n&#123;&quot;s&quot;:&quot;string&quot;, &quot;a&quot;:10, &quot;d&quot;:10.0&#125;\nstdout输出\n&#123;&quot;s&quot;:&quot;string&quot;,&quot;a&quot;:11,&quot;d&quot;:11.0&#125;\n本示例中，在Writer的基础上实现了新的Handler AddOne，将JSON文档中的所有数字加1。自定义Handler只需保证和原有concept一致即可，拥有相同的接口。将不同功能的Handler串联起来，可实现自定义功能。使用SAX风格对JSON进行解析和操作时，无需创建DOM树，每一步通过事件进行触发，处理时内存占用不受JSON文档大小的影响，适用于大型JSON文档的流式处理。\n2. 生成JSON#include &lt;FileWriteStream.hpp&gt;\n#include &lt;Writer.hpp&gt;\n\n#include &lt;iostream&gt;\n\nint main() &#123;\n    json::FileWriteStream os(stdout);\n    json::Writer writer(os);\n\n    writer.StartObject();\n    writer.Key(&quot;B&quot;);\n    writer.StartArray();\n    writer.String(&quot;ByteDance&quot;);\n    writer.String(&quot;BaiDu&quot;);\n    writer.EndArray();\n    writer.Key(&quot;A&quot;);\n    writer.String(&quot;Alibaba&quot;);\n    writer.Key(&quot;T&quot;);\n    writer.String(&quot;Tencent&quot;);\n    writer.EndObject();\n&#125;\n输出：\n&#123;&quot;B&quot;:[&quot;ByteDance&quot;,&quot;BaiDu&quot;],&quot;A&quot;:&quot;Alibaba&quot;,&quot;T&quot;:&quot;Tencent&quot;&#125;\n创建好WriteStream并交由Handler后，调用相应接口即可生成JSON文档。\n测试&amp;&amp;性能mudong-json使用Google Test和Google Benchmark进行测试，测试程序见test和bench目录，测试JSON文件为fastjson提供的真实淘宝网数据。\n编译&amp;&amp;使用$ git clone https:&#x2F;&#x2F;github.com&#x2F;moonlightleaf&#x2F;mudong-json.git\n$ cd mudong-json\n$ git submodule update --init --recursive\n$ mkdir build &amp;&amp; cd build\n$ cmake [-DCMAKE_BUILD_TESTS&#x3D;1] [-DCMAKE_BUILD_BENCHMARK&#x3D;1] [-DCMAKE_BUILD_EXAMPLES&#x3D;1] ..\n$ make\n可以通过选择是否添加**-DCMAKE_BUILD_TESTS&#x3D;1、-DCMAKE_BUILD_BENCHMARK&#x3D;1、-DCMAKE_BUILD_EXAMPLES&#x3D;1选项，来决定是否要对test、bench和example目录下的文件进行编译。mudong-json只包含头文件，在使用时，只需将mudong-json的头文件拷贝至新项目的include**路径下即可。\n参考\nRapidJSON: A fast JSON parser&#x2F;generator for C++ with both SAX&#x2F;DOM style API.\nJSON tutorial: 从零开始的 JSON 库教程.\n\n","slug":"Mudong-JSON","date":"2023-09-28T12:23:12.000Z","categories_index":"项目记录","tags_index":"项目记录","author_index":"月下叶子"},{"id":"819d35bc6064305bb27f20cd57190fee","title":"《SQL必知必会5th》摘要","content":"前提学习环境针对mysql搭建，因此对于书中给出的针对mysql、sql server、Oracle Live SQL等不同具体DBMS的语法，只摘要其描述mysql的部分。\n第1课 了解SQL\n数据库（database）由表（table）组成，同一数据库中，每张表的表名是唯一的。表的每一列代表一个不同的属性，每条数据按照行的方式存储。\n每一行中，都应该有一列或几列可以唯一标识自己，标志位主键。任意两行都不具有相同的主键值；每一行都必须具有一个主键值，且不允许空值NULL；主键列中的值不可修改或更新；主键值不能重用，某行被删除后，其主键不能赋给以后的新行。\n\n第2课 检索数据SELECT prod_name\nFROM products; -- 检索单个列\n\nSELECT prod_id, prod_name, prod_price\nFROM products; -- 检索多个列\n\nSELECT *\nFROM products; -- 检索所有列，*是通配符\n\nSELECT DISTINCT vend_id\nFROM products; -- 检索不同的值（去重）\n\nSELECT DISTINCT vend_id, prod_price\nFROM products; -- 检索不同的列组合值 (1,1)(1,2)(2,1)(2,2)都会被检索出来\n\nSELECT prod_name\nFROM products\nLIMIT 5; -- 返回不超过5行数据\n\nSELECT prod_name\nFROM products\nLIMIT 5 OFFSET 3; -- 返回从行索引3起的5行数据，行索引从0开始计数\n\nSELECT prod_name\nFROM products\nLIMIT 3, 5; -- 简写，含义同上\n\n第3课 排序检索数据SELECT prod_name\nFROM products\nORDER BY prod_name; -- 按序索引，ORDER BY必须为SELECT的最后一个子句\n\nSELECT prod_id, prod_price, prod_name\nFROM products\nORDER BY prod_price, prod_name; -- 按多个列顺序排序\n\nSELECT prod_id, prod_price, prod_name\nFROM products\nORDER BY 2, 3; -- 按列的相对位置排序\n\nSELECT prod_name\nFROM products\nORDER BY prod_name DESC; -- 逆序排列，Descending\n\nSELECT prod_name\nFROM products\nORDER BY prod_name DESC, prod_price; -- DESC只作用与它前面一个列名\n\n第4课 过滤数据SELECT prod_name, prod_price\nFROM products\nWHERE prod_price&gt;10; -- 过滤大于10的值\n\nSELECT prod_name, prod_price\nFROM products\nWHERE prod_price BETWEEN 5 AND 10; -- 筛选5到10之间的\n\nSELECT vend_id, prod_name\nFROM products\nWHERE prod_name &lt;&gt; &#39;Safe&#39;; -- 选择prod_name不为Safe的值，字符串要加引号\n\nSELECT cust_name\nFROM customers\nWHERE cust_email IS NULL; -- 选择email为null的值\n\n\n\n\n操作符\n说明\n\n\n\n&#x3D;\n等于\n\n\n!&#x3D;\n不等于\n\n\n&lt;&gt;\n不等于\n\n\n&lt;\n小于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&gt;\n大于\n\n\n&gt;&#x3D;\n大于等于\n\n\nBETWEEN v1 AND v2\n在指定的两个值之间\n\n\nIS NULL\n为NULL值\n\n\n第5课 高级数据过滤SELECT prod_name, prod_price\nFROM products\nWHERE (vend_id &#x3D; 1001 OR vend_id &#x3D; 1003) AND prod_price &gt;&#x3D; 10; -- 使用AND、OR\n\nSELECT prod_name, prod_price\nFROM products\nWHERE vend_id IN (1001, 1003)\nORDER BY prod_name; -- 使用IN，查找在集合内的数据\n\nSELECT prod_name\nFROM products\nWHERE NOT vend_id &#x3D; 1001 -- 使用NOT，等价于WHERE vend_id !&#x3D; 1001\nORDER BY prod_name;\n\n第6课 用通配符进行过滤% 作为通配符，可以匹配任意数量的任意字符，搭配LIKE一起使用。\nSELECT prod_desc\nFROM products\nWHERE prod_desc LIKE &#39;%si%&#39;;\n\n以下为输出，所有包含si子串的字符数据都被罗列出来：\n+---------------------------------------+\n| prod_desc                             |\n+---------------------------------------+\n| JetPack 1000, intended for single use |\n| Sling, one size fits all              |\n| TNT, red, single stick                |\n+---------------------------------------+\n\n\n\n\n\n\n\n\n\n\nWHERE prod_name LIKE &#39;%&#39;不会匹配产品名称为NULL的行，NULL无法被通配\n对于末尾的空格，可以在匹配子串末尾加上 % 进行通配，也可以用函数去除末尾空格。\n“**_**” 只能通配一个字符，注意末尾空格，额外加上 % 进行处理。\nSELECT prod_name\nFROM products\nWHERE prod_name LIKE &#39;JetPack _000%&#39;;\n\n输出为：\n+--------------+\n| prod_name    |\n+--------------+\n| JetPack 1000 |\n| JetPack 2000 |\n+--------------+\n\n通配符使用需注意：\n\n不要过度使用通配符。如果其他操作符能达到相同的目的，优先使用其他操作符。\n尽量不要把通配符用在搜索模式的开始处，否则搜索会相当耗时。\n\n第7课 创建计算字段可将数据库中的数据稍作处理再返回给客户端程序，在计算字段的语境下，一般用字段来代指列。\nSELECT Concat(vend_name, &#39; (&#39;, vend_country, &#39; )&#39;)\nFROM vendors; -- 字符串拼接，输出格式 vend_name (vend_country)\n\nSELECT Concat(RTRIM(vend_name), &#39; (&#39;, RTRIM(vend_country), &#39; )&#39;)\nFROM vendors; -- RTRIM(field) 去除右端空格，同理有LTRIM去左端和TRIM去两端\n\nSELECT Concat(RTRIM(vend_name), &#39; (&#39;, RTRIM(vend_country), &#39; )&#39;)\nAS vend_title\nFROM vendors; -- 使用AS给字段或值起别名，方便客户端检索\n\n执行算术计算\nSELECT prod_id, \n       quantity,\n       item_price,\n       quantity*item_price AS expanded_price\nFROM orderitems;\n\n计算数量乘以单价，输出为：\n+---------+----------+------------+----------------+\n| prod_id | quantity | item_price | expanded_price |\n+---------+----------+------------+----------------+\n| ANV01   |       10 |       5.99 |          59.90 |\n| ANV02   |        3 |       9.99 |          29.97 |\n| TNT2    |        5 |      10.00 |          50.00 |\n| FB      |        1 |      10.00 |          10.00 |\n| JP2000  |        1 |      55.00 |          55.00 |\n| TNT2    |      100 |      10.00 |        1000.00 |\n| FC      |       50 |       2.50 |         125.00 |\n| FB      |        1 |      10.00 |          10.00 |\n| OL1     |        1 |       8.99 |           8.99 |\n| SLING   |        1 |       4.49 |           4.49 |\n| ANV03   |        1 |      14.99 |          14.99 |\n+---------+----------+------------+----------------+\n\n运算符支持 + - * &#x2F; 四种。\n第8课 使用函数处理数据\n\n\n文本处理函数\n功能\n\n\n\nLEFT()\n返回字符串左边的字符\n\n\nLENGTH()\n返回字符串长度\n\n\nLOWER()\n将字符串转换为小写\n\n\nLTRIM()\n去掉字符串左边的空格\n\n\nRIGHT()\n返回字符串右边的字符\n\n\nRTRIM()\n去掉字符串右边的空格\n\n\nSUBSTRING()\n提取字符串的组成部分\n\n\nSOUNDEX()\n返回字符串的SOUNDEX值\n\n\nUPPER()\n将字符串转换为大写\n\n\n以orders表为例演示用法：\n+-----------+---------------------+---------+\n| order_num | order_date          | cust_id |\n+-----------+---------------------+---------+\n|     20005 | 2005-09-01 00:00:00 |   10001 |\n|     20006 | 2005-09-12 00:00:00 |   10003 |\n|     20007 | 2005-09-30 00:00:00 |   10004 |\n|     20008 | 2005-10-03 00:00:00 |   10005 |\n|     20009 | 2005-10-08 00:00:00 |   10001 |\n+-----------+---------------------+---------+\n\nSELECT LEFT(order_date, 10) -- RIGHT()从右端开始，同理\nFROM orders \nWHERE order_num &#x3D; 20009;\n+----------------------+\n| LEFT(order_date, 10) |\n+----------------------+\n| 2005-10-08           |\n+----------------------+\n\nSELECT LENGTH(order_date) \nfrom orders; -- 可以对字段使用，也可以对单一字符串使用\n+--------------------+\n| LENGTH(order_date) |\n+--------------------+\n|                 19 |\n|                 19 |\n|                 19 |\n|                 19 |\n|                 19 |\n+--------------------+\n\nSELECT UPPER(&#39;Hello world&#39;); -- LOWER()同理\n+----------------------+\n| UPPER(&#39;Hello world&#39;) |\n+----------------------+\n| HELLO WORLD          |\n+----------------------+\n\nSELECT SUBSTRING(&#39;hello world&#39;, 1, 5); -- SUBSTRING(str, start, length)，下标从1开始\n+--------------------------------+\n| SUBSTRING(&#39;hello world&#39;, 1, 5) |\n+--------------------------------+\n| hello                          |\n+--------------------------------+\n\nSELECT cust_name, cust_contack\nFROM customers\nWHERE SOUNDEX(cust_contact) &#x3D; SOUNDEX(&#39;Michael Green&#39;); -- &#39;Michelle Green&#39;会被匹配上，发音相似\n\n\n\n\n日期和时间处理函数\n功能\n\n\n\nYERA()\n从日期中提取年\n\n\nMONTH()\n从日期中提取月\n\n\nDAY()\n从日期中提取日\n\n\nSELECT order_num, cust_id\nFROM orders\nWHERE MONTH(order_date) &#x3D; 9;\n+-----------+---------+\n| order_num | cust_id |\n+-----------+---------+\n|     20005 |   10001 |\n|     20006 |   10003 |\n|     20007 |   10004 |\n+-----------+---------+\n\n\n\n\n数值处理函数\n功能\n\n\n\nABS()\n返回一个数的绝对值\n\n\nCOS()\n返回一个角度的余弦\n\n\nEXP()\n返回一个数的指数值\n\n\nPI()\n返回圆周率的值\n\n\nSIN()\n返回一个角度的正弦\n\n\nSQRT()\n返回一个数的平方根\n\n\nTAN()\n返回一个角度的正切\n\n\n第9课 汇总数据\n\n\n聚集函数\n功能\n\n\n\nAVG()\n返回某列的平均值\n\n\nCOUNT()\n返回某列的行数\n\n\nMAX()\n返回某列的最大值\n\n\nMIN()\n返回某列的最小值\n\n\nSUM()\n返回某列值之和\n\n\nCOUNT(*)会算上NULL，COUNT(field)则忽略NULL\n第10课 分组数据","slug":"SQL-SQL必知必会学习摘要","date":"2023-09-10T07:48:12.000Z","categories_index":"SQL","tags_index":"SQL","author_index":"月下叶子"},{"id":"f800969b8808a99b4d1f639a37a744e3","title":"《SQL必知必会5th》学习环境搭建","content":"学习环境搭建学习SQL过程中难免要多写多练，书中刚好也提供了用来学习的数据库，因此首先进行学习环境的搭建。为方便起见将会使用Docker，需提前安装，教程很多不赘述。\n1.拉取Docker官方提供的mysql镜像\ndocker pull mysql:5.7\n\n2.设置数据卷（Volume）实现数据持久化\n因为容器是无状态的，若不进行数据持久化操作，每次使用容器时数据库数据都是空白的，上次操作产生的数据不会被保存，很不方便。\ndocker volume create mysql_data\n\n创建名为mysql_data的数据卷。\n3.运行mysql容器，挂载数据卷，并设置mysql的root密码\ndocker run -d -v mysql_data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 --name mysql_container mysql:5.7\n我的密码设置为123456，可自行修改。\n4.切换到该容器\ndocker exec -it mysql_container &#x2F;bin&#x2F;bash\n\n切换到我们创建的名为mysql_container容器，进入其终端命令窗口\n5.下载软件包\n有些常用的软件包该镜像内并未提供，需要安装一下。镜像自带了yum，而没有apt，因此使用yum下载安装。\nyum install wget\nyum install unzip\n\n6.下载样例数据库创建脚本\ncd &#x2F;home\nwget https:&#x2F;&#x2F;forta.com&#x2F;wp-content&#x2F;uploads&#x2F;books&#x2F;0672327120&#x2F;mysql_scripts.zip\nunzip mysql_scripts.zip\n\n7.登录mysql服务，并运行创建脚本\nmysql -uroot -p123456\n\n进入mysql命令行后，创建数据库并选择：\nCREATE DATABASE tysql;\nUSE tysql;\n\n执行创建脚本\nsource &#x2F;home&#x2F;create.sql\nsource &#x2F;home&#x2F;populate.sql\n\n8.测试是否成功\nSELECT * FROM products;\n\n有数据表出现即为成功。\n","slug":"SQL-SQL必知必会学习环境搭建","date":"2023-09-10T07:48:12.000Z","categories_index":"SQL","tags_index":"SQL","author_index":"月下叶子"},{"id":"f2ea327fffbd4aafb720991cf16e119c","title":"自定义博客域名","content":"博客域名如果不特殊设置的话，托管在github上博客网址格式都为XXXX.github.io，若想自定义域名，则可以在云服务商处购买自己喜欢的域名并进行解析绑定，比如我的moonlightleaf.cn，别人只需要通过该网址就可以对博客进行访问，方便记忆。\n购买自己喜欢的域名\n此处以腾讯云为例（没有广告，用别的任意一家流程都是一样的），登录腾讯云控制台，挑选并购买一个自己喜欢的域名。\n设置解析\n购买完成后，点击左侧我的域名进行管理。点击解析。\n\n有两个关键的值需要设置，第一个位置为可选为CNAME、txt等格式，选择CNAME即可。第二个位置设置为原博客域名，即github.io后缀结尾的博客网址，最后一位dot符号是自动添加的，格式跟图上保持一致即可。\n仓库设置\n打开存放博客的github仓库，点开Settings-&gt;Pages，将购买的域名填写入Custom domain，并勾选Enforce HTTPS。\n需要在存放博客的github仓库中，添加一个名为CNAME的文件。\n\n\n\n\n\n\n\n\n\n注意文件全名即为CNAME，没有任何后缀。\n在该文件中填写上你自己购买的域名，比如我的就是moonlightleaf.cn，保存在远程仓库中。至此，自定义域名配置就完成了，但解析可能不会立即生效，看控制台的提示，生效后即可通过新域名访问博客。\n优雅配置通过手动往仓库里添加CNAME文件，可以正常使用新域名访问博客，但如果写了新文章并使用hexo d命令发布的话，手动添加的CNAME文件会被覆盖，那么就需要再次手动添加CNAME文件，会很麻烦。\n一劳永逸的做法是，在本地博客目录下的source文件夹下创建该CNAME文件，格式和内容跟之前描述的一样，这样每次发布时，都会将该CNAME文件包含发布至github博客仓库的根目录下，不需要再手动进行添加。\n","slug":"博客-自定义域名","date":"2023-09-09T01:41:12.000Z","categories_index":"博客搭建","tags_index":"博客搭建","author_index":"月下叶子"},{"id":"36a2486607108757adb270ce5bdb8003","title":"Hexo集成gitalk评论区配置-aurora主题","content":"Hexo框架Hexo框架的使用教程挺多的了，根据以下两个链接，足以正常搭建和使用。\nHexo官方中文文档\nhexo+aurora+github+gitalk搭建属于自己的个人博客\n但两个教程中都未对gitalk的配置展开描述，此教程旨在记录gitalk的配置流程。\nGitalk功能\n可作为Hexo框架下的插件，为博客提供评论区功能\n使用Github账号登录后方可评论\n评论存储在Github仓库的issue中\n支持无干扰模式(distractionFreeMode: true)\n\nGitalk官方网址官方网址： https://gitalk.github.io\nGitalk配置流程1.在Github上注册新应用，链接：https://github.com/settings/applications/new\n\nURL链接格式 https://XXXX.github.io ，记得需要加上https:&#x2F;&#x2F;\n2.注册之后会进入如下界面\n\n点击生成client secret，注意client secret在之后将不可见，尽量复制保存至本地。client ID和client secret之后需要填入主题的配置文件当中。\n3.修改aurora主题_config.aurora.yml配置文件中的gitalk相关选项\ngitalk:\n  enable: true\n  autoExpand: true\n  clientID: &#39;xxxxx&#39; \n  clientSecret: &#39;xxxxxxxxx&#39;\n  repo: &#39;xxxxxx&#39; ## dev-blo-comments\n  owner: &#39;moonlightleaf&#39; ## owner name\n  admin: [&#39;moonlightleaf&#39;] ## [&#39;admin_name&#39;]\n  id: uid\n  language: cn\n  distractionFreeMode: true\n  recentComment: true\n  proxy: &#39;&#39;\n\n需要填入上一步生成的client ID和client secret，并填入仓库名，将自己的github用户名设置为owner和admin，别的选项无需修改。最后的proxy选项可以自行设置反向代理，方便国内用户访问（国内用户被墙，可能出现network error的错误提示）。我是魔法常驻用户，因此就没有设置反向代理。\n4.执行命令，重新生成并发布，刷新博客就能看到评论区啦。\nhexo clean &amp; hexo g &amp; hexo d\n\ngitalk貌似在本地测试环境中不能用，因此必须hexo d命令发布后，才能看到评论区。\n","slug":"博客-gitalk配置","date":"2023-09-08T13:38:20.000Z","categories_index":"博客搭建","tags_index":"博客搭建","author_index":"月下叶子"},{"id":"20a581299d5041a583789bd3076d92ff","title":"VS项目常用调试方法","content":" \n\n1.打印数据int a &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; 10; ++i) &#123;\n    a +&#x3D; i;\n#ifdef _DEBUG\n    if (i &#x3D;&#x3D; 5) printf(&quot;debug: i &#x3D;&#x3D; 5, a &#x3D; %d\\n&quot;, a);\n#endif &#x2F;&#x2F;DEBUG\n&#125;\nprintf(&quot;a &#x3D; %d\\n&quot;, a);\n在VC里，debug模式的标识宏为_DEBUG, 在debug模式下该宏被定义，则打印输出i&#x3D;5时的调试信息；在release模式下则不会执行调试打印语句。注意，要尽可能详细地写出调试信息，与一般打印输出区分开。\n2.普通断点\n在指定位置插入断点，代码执行至此便会暂停。\n3.条件断点在待调试代码行，右键，插入条件断点。当程序运行至此处并且判断条件为真时，触发断点。\n\n\n4.条件追踪我们可能想要在触发条件断点时，打印输出一些信息来帮助我们了解程序的运行状况，那么我们可以勾选操作，并添加一些代码，从而将消息记录输出到窗口。假如我们在操作中添加如下代码：\ndebug: a &#x3D; &#123;a&#125;\n\n则会打印输出 debug: a &#x3D; 10。需要注意，当想输出某变量值时，需要用{}来进行捕获，别的字符将直接以字符格式输出。在操作中，还有一些VS为我们提供的变量可以使用，例如打印PID、函数名、堆栈等，前缀一如既往的是$，如图：\n\n假如我们在操作中添加如下代码：\ndebug: $PNAME | $TNAME | $FUNCTION | a &#x3D; &#123;a&#125;\n\n则会打印输出如下：\ndebug: D:\\VSProjects\\ServerProject\\bin\\x64\\Debug\\HelloWorld.exe | 主线程 | main(void) | a &#x3D; 10\n\n5.单步调试多打几个断点，让整体程序分段执行，触发断点时，鼠标悬停至变量上，可显示该变量当前的值。\n若想跳转至某个函数内部进行逐步分析，则需要使用“逐语句”调试，如果用“逐过程”，则不会进入函数内部调试。进入了函数之后如果想跳出，可以点“跳出”。\n6.添加监视当有多个变量需要调试测值的时候，鼠标悬停看值肯定会不方便，因此可以右键点击变量，添加监视，监视窗口如下图：\n\nint arr[] &#x3D; &#123; 1,3,5,7,9 &#125;;\nint* pArr &#x3D; arr;\n\n对于上述两行代码，若直接对arr和pArr添加监视，arr可正常被作为数组监视，而pArr则被认为是单个int变量，指向的值只有1。若想正确的监视pArr，需要右键点击pArr-&gt;快速监视，按如下输入，并点击重新计算即可：\n\n","slug":"VS项目常用调试方法","date":"2022-10-30T16:13:20.000Z","categories_index":"VS","tags_index":"VS","author_index":"月下叶子"},{"id":"f90be0cb91d38e221fc75922bd5a6542","title":"VS项目文件层级管理方案","content":" \n\n1.新建项目文件夹，以项目名称来命名例如，新建项目文件夹，命名为“MyServer”。\n2.在MyServer文件夹下，创建新的控制台项目“HelloCpp”\n3.修改解决方案下的项目配置右键点击项目“HelloCpp”，点击“配置”，按如图所示修改“输出目录”和“中间目录”。\n\n\n其中，$(Param)这样的形式表示VS自带的变量，$(SolutionDir)就表示解决方案目录名；$(Platform)表示当前平台，看是x86还是x64；$(Configuration)表示配置，看是Debug还是Release。\n以图中输出目录为例，表示为将输出目录设置为：解决方案目录的上级目录（..）下的bin下的$(Platform)下的$(Configuration)文件夹。\n4.可在同一解决方案下添加多个项目，并按同样的方式修改配置我们可能想要在触发条件断点时，打印输出一些信息来帮助我们了解程序的运行状况，那么我们可以勾选操作，并添加一些代码，从而将消息记录输出到窗口。假如我们在操作中添加如下代码：\n\n5.生成之后，解决方案的文件目录如下在总的文件夹MyServer目录下，有如下三个文件夹：\n\nbin中存的为输出目录，包含有可执行文件，若要发送可执行文件给别人，可将此文件夹中对应文件发送；HelloCpp中保存的是整个项目的源码，可打包转发给别人；temp中放的是中间文件。\nbin中的文件目录结构如图，划分清晰：\n\nHelloCpp下存有两个项目的源码和项目配置文件：\n\n清晰的文件目录结构划分，可以方便我们对项目文件进行管理，防止文件目录被污染，导致自己都不清楚每个文件到底是用来干嘛的。\n","slug":"VS项目文件层级管理方案","date":"2022-10-30T16:13:20.000Z","categories_index":"VS","tags_index":"VS","author_index":"月下叶子"},{"id":"9f557fa332d329d3a527e81492ff3945","title":"new内存管理","content":"\n\n1.Overview\n2.C++ Memory Primitives\n\n\n分配\n释放\n类属\n可否重载\n\n\n\nmalloc()\nfree()\nC函数\n不可\n\n\nnew\ndelete\nC++表达式（expressions）\n不可\n\n\n::operator new()\n::operator delete()\nC++函数\n可\n\n\nallocate::allocate()\nallocate::deallocate()\nC++标准库\n可自由设计并以之搭配容器\n\n\n注：对于new，还有一种placement new操作，语法为 new(ptr) Constructor(…)，该操作不会申请内存，而是在已经申请好的内存上（ptr即为内存起始位置）调用指定类型的构造函数。该操作即可操作堆上内存，也可操作栈上内存，后续会有针对placement new更详细的讲解。（placement new的其中一种用法，是搭配array new使用，因为array new时，只能调用默认构造函数，想调用别的构造函数必须在array new之后，在指定位置调用placement new来替换原来的默认构造对象。）\n3.四个层面的基本用法void* p1 &#x3D; malloc(512); &#x2F;&#x2F;512 bytes\nfree(p1);\n\ncomplex&lt;int&gt;* p2 &#x3D; new complex&lt;int&gt;; &#x2F;&#x2F;one object\ndelete p2;\n\nvoid* p3 &#x3D; ::operator new(512); &#x2F;&#x2F;512 bytes\n::operator delete p3;\n\n&#x2F;&#x2F;以C++20 GCC为例\nint* p4 &#x3D; allocator&lt;int&gt;().allocate(5); &#x2F;&#x2F;分配 5个ints所需内存空间的大小，并尚未构造\nallocator&lt;int&gt;().deallocate(p4, 5);\n\n前三种操作语法始终如一，但allocator的成员函数接口在不同版本的c++标准和编译器下有所不统一，使用时需注意（以下摘自cpp reference）：\n&#x2F;&#x2F; std::allocator&lt;T&gt;::allocate\npointer allocate( size_type n, const void * hint &#x3D; 0 ); &#x2F;&#x2F;(until C++17)\nT* allocate( std::size_t n, const void * hint); &#x2F;&#x2F;(since C++17)(deprecated)(removed in C++20)\nT* allocate( std::size_t n ); &#x2F;&#x2F;(since C++17)(until C++20)\n[[nodiscard]] constexpr T* allocate( std::size_t n ); &#x2F;&#x2F;(since C++20)\n&#x2F;*parameters\nn\t-\tthe number of objects to allocate storage for\nhint\t-\tpointer to a nearby memory location*&#x2F;\n\n4.new&#x2F;delete expression\n对于new expression（第3条中p2的获取方式），实际主要执行两步操作：首先使用operator new（第3条中p3的获取方式）申请相应大小的内存，然后在该内存位置上调用指定类型的构造函数（constructor，缩写为ctor），将new的参数列表传递给构造函数。\n\nComplex* pc &#x3D; new Complex(1, 2);\n&#x2F;&#x2F;编译器将上述代码转为如下操作：\nComplex* pc;\ntry &#123;\n\tvoid* mem &#x3D; operator new(sizeof(Complex));\n\tpc &#x3D; static_cast&lt;Complex*&gt;(mem);\n\tpc-&gt;Complex(1, 2); &#x2F;&#x2F;只有编译器才可以用此方式调用构造函数，同义替换可运用placement new : new(pc) Complex(1, 2),借此调用ctor\n&#125;\ncatch (std::bad_alloc) &#123;\n\t&#x2F;&#x2F;若allocation失败则不执行constructor\n&#125;\n\n\n对于operator new，其行为由如下代码描述。可以看到operator new的内存申请分配操作其实就是由malloc来执行的，但operator new提供了更多的操作可能性。_callnewh是用户可以设定的函数，当malloc申请内存失败时，通过调用用户自定义_callnewh函数，允许我们在malloc失败时固定地执行一些我们想要执行的操作（比如内存已耗尽或碎片化导致无足够的连续内存，可以释放掉某些可以释放的内存，从而使得malloc成功），后续对此部分有更详细的讲解。\n\nvoid* operator new(size_t size) noexcept\n&#123;&#x2F;&#x2F;try to allocate size bytes\n\tvoid* p;\n\twhile ((p &#x3D; malloc(size)) &#x3D;&#x3D; 0) &#x2F;&#x2F;malloc返回0表示内存分配失败\n\t&#123;&#x2F;&#x2F;buy more memory or return null pointer\n\t\t_TRY_BEGIN\n\t\t\tif (_callnewh(size) &#x3D;&#x3D; 0) break;\n\t\t_CATCH(std::bad_alloc) return (0);\n\t\t_CATCH_END\n\t&#125;\n\treturn (p);\n&#125;\n\n\n对于delete expression，与new expression镜像类似，实际主要执行两步操作：首先调用指针指向对象的析构函数，然后释放指针指向对象所占用的内存。其代码描述如下：\n\nComplex* pc &#x3D; new Complex(1, 2);\ndelete pc;\n&#x2F;&#x2F;编译器将上述delete pc转为如下操作：\npc-&gt;~Complex(); &#x2F;&#x2F;先析构\noperator delete(pc); &#x2F;&#x2F;然后释放内存\n\n\n对于operator delete，某老版本代码中作如下描述（新版本本质是一样的）。对operator new镜像对称，operator delete释放内存的操作是由free来执行的。\n\nvoid __cdecl operator delete(void* p) _THROW0()\n&#123; &#x2F;&#x2F;free an allocated object\n\tfree(p);\n&#125;\n\n\nConstructor &amp; Destructor 直接调用：Ctor的直接调用依赖具体编译器的实现，在VC6下通过，在GCC下不通过，因此要避免这种写法，可用placement new来达到同样的目的；Dtor可直接调用，各编译器下都支持。\n\n5.array new, array delete首先抛出一个问题：我们知道，在语法层面上，new出来一个数组，一定要使用delete []来释放内存。但假如释放时不小心只使用了delete而不是delete []，一定会发生内存泄漏吗？\n来看当正常操作时，我们做了些什么：\nComplex* pca &#x3D; new Complex[3];\n&#x2F;&#x2F;唤起三次ctor\n&#x2F;&#x2F;无法借由参数给予初值\ndelete[] pca; &#x2F;&#x2F;唤起3次dtor\n\n使用array new，创建了含有三个Complex object的数组，其在内存中的分布情况见下图：\n\n可见，在使用array new的时候，除了三个对象外，还附带有一个cookie，这个cookie记录了一些东西，其中最重要的信息就是整块儿内存的长度。这是因为在使用delete[]时，最底层的内存回收依旧是由free完成的，而free若想调用，必须传给它正确的参数，即将要收回内存的大小，通过使用cookie中记录的内存块大小信息，才能正确的回收内存。这种new&amp;delete的cookie机制，在所有编译器下是统一的。当使用delete时，编译器会认为从pca开始的3sizeof(Complex)大小的内存是一个对象，调用一次析构函数（至于调用的是最上层object的dtor还是最下层的，后续有分析），将3sizeof(Complex)大小的内存free掉。由此可见，是否发生内存泄漏的决定性因素并不在数组中对象所占用的内存本身，因为无论使用delete还是delete[]，该数组本身所占用的内存都会被正确的释放掉。内存泄漏的真正的根因在于调用析构函数的次数。\n没有对每个object调用dtor，有什么影响？对class without pointer member来说可能没有影响，对class with pointer member来说通常有影响。以动态内存管理类，如std::string（真名basic_string，用了typedef basic_string string或using string &#x3D; basic_string这样的语法）为例，每个string对象管理一个char*指针，该指针指向一块存有真正字符串的内存。当使用如下代码创建string数组并释放时，内存模型如图所示：\nstring* psa &#x3D; new sting[3];\ndelete psa; &#x2F;&#x2F;错误示例\n\n\n使用delete时，str1、str2和str3所占用的内存都会被释放干净，内存泄漏并没有发生在string对象本身所占用的内存上。但因为使用的是delete而非array delete，会使得编译器误以为psa指向的为单一对象，因此只会调用一次析构函数，只有一个string对象所管理的内存会被正确释放，因此会造成内存泄漏。当使用delete []时，编译器得知psa指向一个数组，因此会调用三次析构函数，将所有内存都正确释放。\narray new的构造顺序为从低地址到高地址（秩由小到大），array delete的析构顺序为从高地址到低地址（秩由大到小），二者顺序相反。\n\n注：debug和release模式下编译得到的代码以及对象内存分布是有很大差异的，debug模式下保留了很多用于debug的额外代码，占用更多内存（上图中也有所体现）。软件发行使用release版本。\n6.Replacement newplacement new的作用，在指针指定的位置调用构造函数，用新对象覆盖掉原对象，并不重新申请内存。没有所谓的placement delete与之特殊对应，正确使用delete或array delete即可。\n基本使用语法如下：\n#include &lt;new&gt;\nchar* buf &#x3D; new char[sizeof(Complex) * 3];\nComplex* pc &#x3D; new(buf) Complex(1, 2);\ndelete [] buf;\n\n编译器会将placemen new那一行转换为如下操作：\nComplex* pc;\ntry &#123;\n\tvoid* mem &#x3D; operator new(sizeof(Complex), buf); &#x2F;&#x2F;allocate\n\tpc &#x3D; static_cast&lt;Complex*&gt;(mem); &#x2F;&#x2F;cast\n\tpc-&gt;Complex::Complex(1, 2); &#x2F;&#x2F;construct\n&#125;\ncatch( std::bad_alloc ) &#123;\n\t&#x2F;&#x2F;若allocation失败就不执行constructor\n&#125;\n\n这里调用了双参数的operator new，不会申请新的内存，源码如下：\nvoid* operator new(size_t, void* loc) \n&#123; return loc; &#125;\n\n7.重载首先来看C++应用程序分配内存的途径，从而确定我们重载的是哪个环节：\n\n该图中有以下几个关键点：\n\nexpression是不可改变，不可重载的（初学者会误认为重载new、delete是重载的这里，但其实不是）\n重载是重载operator new&#x2F;delete，一般重载类内的operator new（Foo::operator new(…),会被默认声明为static成员函数）。也可重载全局::operator new，但几乎不这样做。\n图中右上角给出了一种重载new的场景：我们希望一次申请一大块内存，自行切割成小块内存作为每个对象，这样可以节省cookie占用的空间。\n后续会有更多关于std::allocator的内容，现代内存管理方式。\n\n\n从图上实例我们可以很清楚地看出重载接管了内存分配的哪个环节。重载operator new[]&#x2F;delete[]和上述过程一致，不再赘述。\n8.重载示例（operator new）\n\n值得关注的点：\n\n以不含虚函数的输出为例，单个对象size为12（string的大小依赖于编译器的实现，不同实现下，大小不一样），5个对象构成的数组size为5*12 + 4 &#x3D; 64，应该是在32位系统下的结果。\n\n若想使用全局操作符(几乎没有人这么做），需要标明作用域，如下：\nFoo* p &#x3D; ::new Foo(7);\n::delete p;\n\nFoo* pArray &#x3D; ::new Foo[5];\n::delete [] pArray;","slug":"C++new内存管理","date":"2022-10-15T16:13:20.000Z","categories_index":"C++","tags_index":"C++","author_index":"月下叶子"},{"id":"adf2676e452953c4451f885c2a466f48","title":"设计模式by李建忠","content":"《 设计模式 》by李建忠 - 重点总结模板方法Template Method1.动机Motivation\n\n在软件构建过程中，对于某一项任务，它常常有稳定的整体操作框架，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架和应用之间的关系）而无法和任务的整体结构同时实现。\n如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？\n\n2.代码样例\n2.1 Original Example\n&#x2F;&#x2F;&quot;template1_lib.cpp&quot;\n&#x2F;&#x2F;程序库开发人员\nclass Library &#123;\npublic:\n\tvoid Step1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tvoid Step3() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tvoid Step5() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;&quot;template1_app.cpp&quot;\n&#x2F;&#x2F;应用程序开发人员\nclass Application &#123;\npublic:\n    bool Step2() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n    void Step4() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\nint main() &#123;\n    Library lib();\n    Application app();\n    \n    &#x2F;&#x2F;以某种固定的流程执行任务\n    lib.Step1();\n    \n    if (app.Step2()) &#123;\n        lib.Step3();\n    &#125;\n    \n    for (int i &#x3D; 0; i &lt; 4; i++) &#123;\n        app.Step4();\n    &#125;\n    \n    lib.Step5();\n&#125;\n\n\n结构化软件设计流程\n\n\n\n\n\nLibrary开发人员\nApplication开发人员\n\n\n\n（1）开发1、3、5三个步骤\n（1）开发2、4两个步骤\n\n\n\n（2）程序主流程\n\n\n2.2 Advanced Example\n&#x2F;&#x2F;&quot;template2_lib.cpp&quot;\n&#x2F;&#x2F;程序库开发人员\nclass Library &#123;\npublic:\n    &#x2F;&#x2F;稳定 template method\n    void Run() &#123;\n        Step1();\n        \n        if (Step2()) &#123; &#x2F;&#x2F;支持变化 &#x3D;&#x3D;&gt; 虚函数的多态调用\n            Step3();\n        &#125;\n        \n        for (int i &#x3D; 0; i &lt; 4; i++) &#123;\n            Step4(); &#x2F;&#x2F;支持变化 &#x3D;&#x3D;&gt; 虚函数的多态调用\n        &#125;\n        \n        Step5();\n    &#125;\n    \n    virtual ~Library() &#123; &#125;\n    \nprotected:\n    void Step1() &#123; &#x2F;&#x2F;稳定\n        &#x2F;&#x2F;...\n    &#125;\n    void Step3() &#123; &#x2F;&#x2F;稳定\n    \t&#x2F;&#x2F;...\n    &#125;\n    void Step5() &#123; &#x2F;&#x2F;稳定\n        &#x2F;&#x2F;...\n    &#125;\n    \n    virtual bool Step2() &#x3D; 0; &#x2F;&#x2F;变化\n    virtual void Step4() &#x3D; 0; &#x2F;&#x2F;变化\n&#125;;\n&#x2F;&#x2F;&quot;template2_app.cpp&quot;\n&#x2F;&#x2F;应用程序开发人员\nclass Application : public Library &#123;\nprotected:\n    virtual bool Step2() &#123;\n        &#x2F;&#x2F;... 子类重写实现\n    &#125;\n    virtual void Step4() &#123;\n        &#x2F;&#x2F;... 子类重写实现\n    &#125;\n&#125;;\n\n\nint main() &#123;\n    Library* pLib &#x3D; new Application();\n    lib-&gt;Run();\n    \n    delete pLib;\n&#125;\n\n\n面向对象软件设计流程\n\n\n\n\n\nLibrary开发人员\nApplication开发人员\n\n\n\n（1）开发1、3、5三个步骤\n（1）开发2、4两个步骤\n\n\n（2）程序主流程\n\n\n\n3.Template Method定义\n定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类。Template Method使得子类可以不改变（复用）一个算法的结构即可重定义（override重写）该算法的某些特定步骤。\n4.类图\n\n模板方法Template Method1.动机Motivation\n\n在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。\n如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？\n\n2.代码样例\n2.1Original Example\n&#x2F;&#x2F;&quot;strategy1.cpp&quot;\nenum TaxBase &#123;\n    CN_Tax;\n    US_Tax;\n    DE_Tax;\n    FR_Tax; &#x2F;&#x2F;添加需求，更改\n&#125;;\n\nclass SalesOrder &#123;\n    TaxBase tax;\npublic:\n    double CalculateTax() &#123;\n        &#x2F;&#x2F;...\n        if (tax &#x3D;&#x3D; CN_Tax) &#123;\n            &#x2F;&#x2F;CN************\n        &#125;\n        else if (tax &#x3D;&#x3D; US_Tax) &#123;\n            &#x2F;&#x2F;US************\n        &#125;\n        else if (tax &#x3D;&#x3D; DE_Tax) &#123;\n            &#x2F;&#x2F;DE************\n        &#125;\n        else if (tax &#x3D;&#x3D; FR_Tax) &#123; &#x2F;&#x2F;跟随需求更改..................违背了开闭原则（开放扩展，封闭修改）\n            &#x2F;&#x2F;FR************\n        &#125;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;;\n\n2.2Advanced Example\n&#x2F;&#x2F;&quot;strategy2.cpp&quot;\nclass TaxStrategy &#123;\npublic:\n    virtual double CalculateTex(const Context&amp; context) &#x3D; 0;\n    virtual ~TaxStrategy() &#123; &#125;\n&#125;;\n\nclass CNTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass USTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass DETax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\n&#x2F;***************添加新的国家税费计算需求***************&#x2F;\nclass FRTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass SalesOrder &#123;\nprivate:\n    TaxStrategy* strategy;\npublic:\n    SalesOrder(StrategyFactory* strategyFactory) &#123;\n        this-&gt;strategy &#x3D; strategyFactory-&gt;NewStrategy();\n    &#125;\n    ~SalesOrder() &#123;\n        delete this-&gt;strategy;\n    &#125;\n    \n    double CalculateTax() &#123;\n        &#x2F;&#x2F;...\n        Context context();\n        \n        double val &#x3D; strategy-&gt;CalculateTax(context); &#x2F;&#x2F;多态调用\n        &#x2F;&#x2F;...\n    &#125;\n&#125;;\n3.Strategy策略模式定义\n定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可以独立于使用它的客户程序（稳定）而变化（扩展，子类化）。\n4.类图\n\n5.要点总结\n\nStrategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。\nStrategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句（if-else or switch-case)的代码通常都需要Strategy模式。\n如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。\n\n观察者模式Observer&#x2F;Event1.动机Motivation\n\n在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。\n使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。\n\n","slug":"设计模式","date":"2022-10-14T16:13:20.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"月下叶子"},{"id":"7300152523883e0845d647300bd22677","title":"面向对象设计原则","content":"面向对象设计原则1.依赖倒置原则（DIP）\n\n高层模块（稳定）不应该依赖低层模块（变化），二者都应该依赖于抽象（稳定）。\n抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。\n\n2.开放封闭原则（OCP）\n\n对扩展开放，对更改封闭。\n类模块应该是可扩展，但是不可修改。\n\n3.单一职责原则（SRP）\n\n一个类应该仅有一个引起它变化的原因。\n变化的方向隐含着类的责任。\n\n4.Liskov替换原则（LSP）\n\n子类必须能够替换它们的基类。\n继承表达类型抽象。\n\n5.接口隔离原则（ISP）\n\n不应该强迫客户程序依赖它们不用的方法。\n接口应该小而完备。\n\n**6.优先使用对象组合，而不是类继承\n\n类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。\n类继承在某种程度上破坏了封装性，子类父类耦合度高。\n对象组合只要求被破坏的对象具有良好定义的接口，耦合度低。\n\n7.封装变化点\n\n使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响，从而实现层次间的松耦合。\n\n8.针对接口编程，而不是针对实现编程\n\n不将变量类型声明为某个特定的具体类，而是声明为某个接口。（主要指业务类型而非string、vector这些）\n客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。\n客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。\n\n","slug":"设计模式-面向对象设计原则","date":"2022-10-14T16:13:20.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"月下叶子"}]