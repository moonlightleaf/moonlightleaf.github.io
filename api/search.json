[{"id":"f800969b8808a99b4d1f639a37a744e3","title":"《SQL必知必会5th》学习环境搭建","content":"学习环境搭建学习SQL过程中难免要多写多练，书中刚好也提供了用来学习的数据库，因此首先进行学习环境的搭建。为方便起见将会使用Docker，需提前安装，教程很多不赘述。\n1.拉取Docker官方提供的mysql镜像\ndocker pull mysql:5.7\n\n2.设置数据卷（Volume）实现数据持久化\n因为容器是无状态的，若不进行数据持久化操作，每次使用容器时数据库数据都是空白的，上次操作产生的数据不会被保存，很不方便。\ndocker volume create mysql_data\n\n创建名为mysql_data的数据卷。\n3.运行mysql容器，挂载数据卷，并设置mysql的root密码\ndocker run -d -v mysql_data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 --name mysql_container mysql:5.7\n我的密码设置为123456，可自行修改。\n4.切换到该容器\ndocker exec -it mysql_container &#x2F;bin&#x2F;bash\n\n切换到我们创建的名为mysql_container容器，进入其终端命令窗口\n5.下载软件包\n有些常用的软件包该镜像内并未提供，需要安装一下。镜像自带了yum，而没有apt，因此使用yum下载安装。\nyum install wget\nyum install unzip\n**\n6.下载样例数据库创建脚本\ncd &#x2F;home\nwget https:&#x2F;&#x2F;forta.com&#x2F;wp-content&#x2F;uploads&#x2F;books&#x2F;0672327120&#x2F;mysql_scripts.zip\nunzip mysql_scripts.zip\n\n7.登录mysql服务，并运行创建脚本\nmysql -uroot -p123456\n\n进入mysql命令行后，创建数据库并选择：\nCREATE DATABASE tysql;\nUSE tysql;\n\n执行创建脚本\nsource &#x2F;home&#x2F;create.sql\nsource &#x2F;home&#x2F;populate.sql\n\n8.测试是否成功\nSELECT * FROM products;\n\n有数据表出现即为成功。\n","slug":"SQL-SQL必知必会学习环境搭建","date":"2023-09-10T07:48:12.000Z","categories_index":"SQL","tags_index":"SQL","author_index":"月下叶子"},{"id":"819d35bc6064305bb27f20cd57190fee","title":"《SQL必知必会5th》摘要","content":"前提学习环境针对mysql搭建，因此对于书中给出的针对mysql、sql server、Oracle Live SQL等不同具体DBMS的语法，只摘要其描述mysql的部分。\n第1课 了解SQL\n数据库（database）由表（table）组成，同一数据库中，每张表的表名是唯一的。表的每一列代表一个不同的属性，每条数据按照行的方式存储。\n每一行中，都应该有一列或几列可以唯一标识自己，标志位主键。任意两行都不具有相同的主键值；每一行都必须具有一个主键值，且不允许空值NULL；主键列中的值不可修改或更新；主键值不能重用，某行被删除后，其主键不能赋给以后的新行。\n\n第2课 检索数据SELECT prod_name\nFROM products; -- 检索单个列\n\nSELECT prod_id, prod_name, prod_price\nFROM products; -- 检索多个列\n\nSELECT *\nFROM products; -- 检索所有列，*是通配符\n\nSELECT DISTINCT vend_id\nFROM products; -- 检索不同的值（去重）\n\nSELECT DISTINCT vend_id, prod_price\nFROM products; -- 检索不同的列组合值 (1,1)(1,2)(2,1)(2,2)都会被检索出来\n\nSELECT prod_name\nFROM products\nLIMIT 5; -- 返回不超过5行数据\n\nSELECT prod_name\nFROM products\nLIMIT 5 OFFSET 3; -- 返回从行索引3起的5行数据，行索引从0开始计数\n\nSELECT prod_name\nFROM products\nLIMIT 3, 5; -- 简写，含义同上\n\n第3课 排序检索数据SELECT prod_name\nFROM products\nORDER BY prod_name; -- 按序索引，ORDER BY必须为SELECT的最后一个子句\n\nSELECT prod_id, prod_price, prod_name\nFROM products\nORDER BY prod_price, prod_name; -- 按多个列顺序排序\n\nSELECT prod_id, prod_price, prod_name\nFROM products\nORDER BY 2, 3; -- 按列的相对位置排序\n\nSELECT prod_name\nFROM products\nORDER BY prod_name DESC; -- 逆序排列，Descending\n\nSELECT prod_name\nFROM products\nORDER BY prod_name DESC, prod_price; -- DESC只作用与它前面一个列名\n\n第4课 过滤数据SELECT prod_name, prod_price\nFROM products\nWHERE prod_price&gt;10; -- 过滤大于10的值\n\nSELECT prod_name, prod_price\nFROM products\nWHERE prod_price BETWEEN 5 AND 10; -- 筛选5到10之间的\n\nSELECT vend_id, prod_name\nFROM products\nWHERE prod_name &lt;&gt; &#39;Safe&#39;; -- 选择prod_name不为Safe的值，字符串要加引号\n\nSELECT cust_name\nFROM customers\nWHERE cust_email IS NULL; -- 选择email为null的值\n\n\n\n\n操作符\n说明\n\n\n\n&#x3D;\n等于\n\n\n!&#x3D;\n不等于\n\n\n&lt;&gt;\n不等于\n\n\n&lt;\n小于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&gt;\n大于\n\n\n&gt;&#x3D;\n大于等于\n\n\nBETWEEN v1 AND v2\n在指定的两个值之间\n\n\nIS NULL\n为NULL值\n\n\n","slug":"SQL-SQL必知必会学习摘要","date":"2023-09-10T07:48:12.000Z","categories_index":"SQL","tags_index":"SQL","author_index":"月下叶子"},{"id":"f2ea327fffbd4aafb720991cf16e119c","title":"自定义博客域名","content":"博客域名如果不特殊设置的话，托管在github上博客网址格式都为XXXX.github.io，若想自定义域名，则可以在云服务商处购买自己喜欢的域名并进行解析绑定，比如我的moonlightleaf.cn，别人只需要通过该网址就可以对博客进行访问，方便记忆。\n购买自己喜欢的域名\n此处以腾讯云为例（没有广告，用别的任意一家流程都是一样的），登录腾讯云控制台，挑选并购买一个自己喜欢的域名。\n设置解析\n购买完成后，点击左侧我的域名进行管理。点击解析。\n\n有两个关键的值需要设置，第一个位置为可选为CNAME、txt等格式，选择CNAME即可。第二个位置设置为原博客域名，即github.io后缀结尾的博客网址，最后一位dot符号是自动添加的，格式跟图上保持一致即可。\n仓库设置\n打开存放博客的github仓库，点开Settings-&gt;Pages，将购买的域名填写入Custom domain，并勾选Enforce HTTPS。\n需要在存放博客的github仓库中，添加一个名为CNAME的文件。\n\n\n\n\n\n\n\n\n\n注意文件全名即为CNAME，没有任何后缀。\n在该文件中填写上你自己购买的域名，比如我的就是moonlightleaf.cn，保存在远程仓库中。至此，自定义域名配置就完成了，但解析可能不会立即生效，看控制台的提示，生效后即可通过新域名访问博客。\n优雅配置通过手动往仓库里添加CNAME文件，可以正常使用新域名访问博客，但如果写了新文章并使用hexo d命令发布的话，手动添加的CNAME文件会被覆盖，那么就需要再次手动添加CNAME文件，会很麻烦。\n一劳永逸的做法是，在本地博客目录下的source文件夹下创建该CNAME文件，格式和内容跟之前描述的一样，这样每次发布时，都会将该CNAME文件包含发布至github博客仓库的根目录下，不需要再手动进行添加。\n","slug":"博客-自定义域名","date":"2023-09-09T01:41:12.000Z","categories_index":"博客搭建","tags_index":"博客搭建","author_index":"月下叶子"},{"id":"36a2486607108757adb270ce5bdb8003","title":"Hexo集成gitalk评论区配置-aurora主题","content":"Hexo框架Hexo框架的使用教程挺多的了，根据以下两个链接，足以正常搭建和使用。\nHexo官方中文文档\nhexo+aurora+github+gitalk搭建属于自己的个人博客\n但两个教程中都未对gitalk的配置展开描述，此教程旨在记录gitalk的配置流程。\nGitalk功能\n可作为Hexo框架下的插件，为博客提供评论区功能\n使用Github账号登录后方可评论\n评论存储在Github仓库的issue中\n支持无干扰模式(distractionFreeMode: true)\n\nGitalk官方网址官方网址： https://gitalk.github.io\nGitalk配置流程1.在Github上注册新应用，链接：https://github.com/settings/applications/new\n\nURL链接格式 https://XXXX.github.io ，记得需要加上https:&#x2F;&#x2F;\n2.注册之后会进入如下界面\n\n点击生成client secret，注意client secret在之后将不可见，尽量复制保存至本地。client ID和client secret之后需要填入主题的配置文件当中。\n3.修改aurora主题_config.aurora.yml配置文件中的gitalk相关选项\ngitalk:\n  enable: true\n  autoExpand: true\n  clientID: &#39;xxxxx&#39; \n  clientSecret: &#39;xxxxxxxxx&#39;\n  repo: &#39;xxxxxx&#39; ## dev-blo-comments\n  owner: &#39;moonlightleaf&#39; ## owner name\n  admin: [&#39;moonlightleaf&#39;] ## [&#39;admin_name&#39;]\n  id: uid\n  language: cn\n  distractionFreeMode: true\n  recentComment: true\n  proxy: &#39;&#39;\n\n需要填入上一步生成的client ID和client secret，并填入仓库名，将自己的github用户名设置为owner和admin，别的选项无需修改。最后的proxy选项可以自行设置反向代理，方便国内用户访问（国内用户被墙，可能出现network error的错误提示）。我是魔法常驻用户，因此就没有设置反向代理。\n4.执行命令，重新生成并发布，刷新博客就能看到评论区啦。\nhexo clean &amp; hexo g &amp; hexo d\n\ngitalk貌似在本地测试环境中不能用，因此必须hexo d命令发布后，才能看到评论区。\n","slug":"博客-gitalk配置","date":"2023-09-08T13:38:20.000Z","categories_index":"博客搭建","tags_index":"博客搭建","author_index":"月下叶子"},{"id":"f90be0cb91d38e221fc75922bd5a6542","title":"VS项目文件层级管理方案","content":" \n\n1.新建项目文件夹，以项目名称来命名例如，新建项目文件夹，命名为“MyServer”。\n2.在MyServer文件夹下，创建新的控制台项目“HelloCpp”\n3.修改解决方案下的项目配置右键点击项目“HelloCpp”，点击“配置”，按如图所示修改“输出目录”和“中间目录”。\n\n\n其中，$(Param)这样的形式表示VS自带的变量，$(SolutionDir)就表示解决方案目录名；$(Platform)表示当前平台，看是x86还是x64；$(Configuration)表示配置，看是Debug还是Release。\n以图中输出目录为例，表示为将输出目录设置为：解决方案目录的上级目录（..）下的bin下的$(Platform)下的$(Configuration)文件夹。\n4.可在同一解决方案下添加多个项目，并按同样的方式修改配置我们可能想要在触发条件断点时，打印输出一些信息来帮助我们了解程序的运行状况，那么我们可以勾选操作，并添加一些代码，从而将消息记录输出到窗口。假如我们在操作中添加如下代码：\n\n5.生成之后，解决方案的文件目录如下在总的文件夹MyServer目录下，有如下三个文件夹：\n\nbin中存的为输出目录，包含有可执行文件，若要发送可执行文件给别人，可将此文件夹中对应文件发送；HelloCpp中保存的是整个项目的源码，可打包转发给别人；temp中放的是中间文件。\nbin中的文件目录结构如图，划分清晰：\n\nHelloCpp下存有两个项目的源码和项目配置文件：\n\n清晰的文件目录结构划分，可以方便我们对项目文件进行管理，防止文件目录被污染，导致自己都不清楚每个文件到底是用来干嘛的。\n","slug":"VS项目文件层级管理方案","date":"2022-10-30T16:13:20.000Z","categories_index":"VS","tags_index":"VS","author_index":"月下叶子"},{"id":"20a581299d5041a583789bd3076d92ff","title":"VS项目常用调试方法","content":" \n\n1.打印数据int a &#x3D; 0;\nfor (int i &#x3D; 1; i &lt;&#x3D; 10; ++i) &#123;\n    a +&#x3D; i;\n#ifdef _DEBUG\n    if (i &#x3D;&#x3D; 5) printf(&quot;debug: i &#x3D;&#x3D; 5, a &#x3D; %d\\n&quot;, a);\n#endif &#x2F;&#x2F;DEBUG\n&#125;\nprintf(&quot;a &#x3D; %d\\n&quot;, a);\n在VC里，debug模式的标识宏为_DEBUG, 在debug模式下该宏被定义，则打印输出i&#x3D;5时的调试信息；在release模式下则不会执行调试打印语句。注意，要尽可能详细地写出调试信息，与一般打印输出区分开。\n2.普通断点\n在指定位置插入断点，代码执行至此便会暂停。\n3.条件断点在待调试代码行，右键，插入条件断点。当程序运行至此处并且判断条件为真时，触发断点。\n\n\n4.条件追踪我们可能想要在触发条件断点时，打印输出一些信息来帮助我们了解程序的运行状况，那么我们可以勾选操作，并添加一些代码，从而将消息记录输出到窗口。假如我们在操作中添加如下代码：\ndebug: a &#x3D; &#123;a&#125;\n\n则会打印输出 debug: a &#x3D; 10。需要注意，当想输出某变量值时，需要用{}来进行捕获，别的字符将直接以字符格式输出。在操作中，还有一些VS为我们提供的变量可以使用，例如打印PID、函数名、堆栈等，前缀一如既往的是$，如图：\n\n假如我们在操作中添加如下代码：\ndebug: $PNAME | $TNAME | $FUNCTION | a &#x3D; &#123;a&#125;\n\n则会打印输出如下：\ndebug: D:\\VSProjects\\ServerProject\\bin\\x64\\Debug\\HelloWorld.exe | 主线程 | main(void) | a &#x3D; 10\n\n5.单步调试多打几个断点，让整体程序分段执行，触发断点时，鼠标悬停至变量上，可显示该变量当前的值。\n若想跳转至某个函数内部进行逐步分析，则需要使用“逐语句”调试，如果用“逐过程”，则不会进入函数内部调试。进入了函数之后如果想跳出，可以点“跳出”。\n6.添加监视当有多个变量需要调试测值的时候，鼠标悬停看值肯定会不方便，因此可以右键点击变量，添加监视，监视窗口如下图：\n\nint arr[] &#x3D; &#123; 1,3,5,7,9 &#125;;\nint* pArr &#x3D; arr;\n\n对于上述两行代码，若直接对arr和pArr添加监视，arr可正常被作为数组监视，而pArr则被认为是单个int变量，指向的值只有1。若想正确的监视pArr，需要右键点击pArr-&gt;快速监视，按如下输入，并点击重新计算即可：\n\n","slug":"VS项目常用调试方法","date":"2022-10-30T16:13:20.000Z","categories_index":"VS","tags_index":"VS","author_index":"月下叶子"},{"id":"9f557fa332d329d3a527e81492ff3945","title":"new内存管理","content":"\n\n1.Overview\n2.C++ Memory Primitives\n\n\n分配\n释放\n类属\n可否重载\n\n\n\nmalloc()\nfree()\nC函数\n不可\n\n\nnew\ndelete\nC++表达式（expressions）\n不可\n\n\n::operator new()\n::operator delete()\nC++函数\n可\n\n\nallocate::allocate()\nallocate::deallocate()\nC++标准库\n可自由设计并以之搭配容器\n\n\n注：对于new，还有一种placement new操作，语法为 new(ptr) Constructor(…)，该操作不会申请内存，而是在已经申请好的内存上（ptr即为内存起始位置）调用指定类型的构造函数。该操作即可操作堆上内存，也可操作栈上内存，后续会有针对placement new更详细的讲解。（placement new的其中一种用法，是搭配array new使用，因为array new时，只能调用默认构造函数，想调用别的构造函数必须在array new之后，在指定位置调用placement new来替换原来的默认构造对象。）\n3.四个层面的基本用法void* p1 &#x3D; malloc(512); &#x2F;&#x2F;512 bytes\nfree(p1);\n\ncomplex&lt;int&gt;* p2 &#x3D; new complex&lt;int&gt;; &#x2F;&#x2F;one object\ndelete p2;\n\nvoid* p3 &#x3D; ::operator new(512); &#x2F;&#x2F;512 bytes\n::operator delete p3;\n\n&#x2F;&#x2F;以C++20 GCC为例\nint* p4 &#x3D; allocator&lt;int&gt;().allocate(5); &#x2F;&#x2F;分配 5个ints所需内存空间的大小，并尚未构造\nallocator&lt;int&gt;().deallocate(p4, 5);\n\n前三种操作语法始终如一，但allocator的成员函数接口在不同版本的c++标准和编译器下有所不统一，使用时需注意（以下摘自cpp reference）：\n&#x2F;&#x2F; std::allocator&lt;T&gt;::allocate\npointer allocate( size_type n, const void * hint &#x3D; 0 ); &#x2F;&#x2F;(until C++17)\nT* allocate( std::size_t n, const void * hint); &#x2F;&#x2F;(since C++17)(deprecated)(removed in C++20)\nT* allocate( std::size_t n ); &#x2F;&#x2F;(since C++17)(until C++20)\n[[nodiscard]] constexpr T* allocate( std::size_t n ); &#x2F;&#x2F;(since C++20)\n&#x2F;*parameters\nn\t-\tthe number of objects to allocate storage for\nhint\t-\tpointer to a nearby memory location*&#x2F;\n\n4.new&#x2F;delete expression\n对于new expression（第3条中p2的获取方式），实际主要执行两步操作：首先使用operator new（第3条中p3的获取方式）申请相应大小的内存，然后在该内存位置上调用指定类型的构造函数（constructor，缩写为ctor），将new的参数列表传递给构造函数。\n\nComplex* pc &#x3D; new Complex(1, 2);\n&#x2F;&#x2F;编译器将上述代码转为如下操作：\nComplex* pc;\ntry &#123;\n\tvoid* mem &#x3D; operator new(sizeof(Complex));\n\tpc &#x3D; static_cast&lt;Complex*&gt;(mem);\n\tpc-&gt;Complex(1, 2); &#x2F;&#x2F;只有编译器才可以用此方式调用构造函数，同义替换可运用placement new : new(pc) Complex(1, 2),借此调用ctor\n&#125;\ncatch (std::bad_alloc) &#123;\n\t&#x2F;&#x2F;若allocation失败则不执行constructor\n&#125;\n\n\n对于operator new，其行为由如下代码描述。可以看到operator new的内存申请分配操作其实就是由malloc来执行的，但operator new提供了更多的操作可能性。_callnewh是用户可以设定的函数，当malloc申请内存失败时，通过调用用户自定义_callnewh函数，允许我们在malloc失败时固定地执行一些我们想要执行的操作（比如内存已耗尽或碎片化导致无足够的连续内存，可以释放掉某些可以释放的内存，从而使得malloc成功），后续对此部分有更详细的讲解。\n\nvoid* operator new(size_t size) noexcept\n&#123;&#x2F;&#x2F;try to allocate size bytes\n\tvoid* p;\n\twhile ((p &#x3D; malloc(size)) &#x3D;&#x3D; 0) &#x2F;&#x2F;malloc返回0表示内存分配失败\n\t&#123;&#x2F;&#x2F;buy more memory or return null pointer\n\t\t_TRY_BEGIN\n\t\t\tif (_callnewh(size) &#x3D;&#x3D; 0) break;\n\t\t_CATCH(std::bad_alloc) return (0);\n\t\t_CATCH_END\n\t&#125;\n\treturn (p);\n&#125;\n\n\n对于delete expression，与new expression镜像类似，实际主要执行两步操作：首先调用指针指向对象的析构函数，然后释放指针指向对象所占用的内存。其代码描述如下：\n\nComplex* pc &#x3D; new Complex(1, 2);\ndelete pc;\n&#x2F;&#x2F;编译器将上述delete pc转为如下操作：\npc-&gt;~Complex(); &#x2F;&#x2F;先析构\noperator delete(pc); &#x2F;&#x2F;然后释放内存\n\n\n对于operator delete，某老版本代码中作如下描述（新版本本质是一样的）。对operator new镜像对称，operator delete释放内存的操作是由free来执行的。\n\nvoid __cdecl operator delete(void* p) _THROW0()\n&#123; &#x2F;&#x2F;free an allocated object\n\tfree(p);\n&#125;\n\n\nConstructor &amp; Destructor 直接调用：Ctor的直接调用依赖具体编译器的实现，在VC6下通过，在GCC下不通过，因此要避免这种写法，可用placement new来达到同样的目的；Dtor可直接调用，各编译器下都支持。\n\n5.array new, array delete首先抛出一个问题：我们知道，在语法层面上，new出来一个数组，一定要使用delete []来释放内存。但假如释放时不小心只使用了delete而不是delete []，一定会发生内存泄漏吗？\n来看当正常操作时，我们做了些什么：\nComplex* pca &#x3D; new Complex[3];\n&#x2F;&#x2F;唤起三次ctor\n&#x2F;&#x2F;无法借由参数给予初值\ndelete[] pca; &#x2F;&#x2F;唤起3次dtor\n\n使用array new，创建了含有三个Complex object的数组，其在内存中的分布情况见下图：\n\n可见，在使用array new的时候，除了三个对象外，还附带有一个cookie，这个cookie记录了一些东西，其中最重要的信息就是整块儿内存的长度。这是因为在使用delete[]时，最底层的内存回收依旧是由free完成的，而free若想调用，必须传给它正确的参数，即将要收回内存的大小，通过使用cookie中记录的内存块大小信息，才能正确的回收内存。这种new&amp;delete的cookie机制，在所有编译器下是统一的。当使用delete时，编译器会认为从pca开始的3sizeof(Complex)大小的内存是一个对象，调用一次析构函数（至于调用的是最上层object的dtor还是最下层的，后续有分析），将3sizeof(Complex)大小的内存free掉。由此可见，是否发生内存泄漏的决定性因素并不在数组中对象所占用的内存本身，因为无论使用delete还是delete[]，该数组本身所占用的内存都会被正确的释放掉。内存泄漏的真正的根因在于调用析构函数的次数。\n没有对每个object调用dtor，有什么影响？对class without pointer member来说可能没有影响，对class with pointer member来说通常有影响。以动态内存管理类，如std::string（真名basic_string，用了typedef basic_string string或using string &#x3D; basic_string这样的语法）为例，每个string对象管理一个char*指针，该指针指向一块存有真正字符串的内存。当使用如下代码创建string数组并释放时，内存模型如图所示：\nstring* psa &#x3D; new sting[3];\ndelete psa; &#x2F;&#x2F;错误示例\n\n\n使用delete时，str1、str2和str3所占用的内存都会被释放干净，内存泄漏并没有发生在string对象本身所占用的内存上。但因为使用的是delete而非array delete，会使得编译器误以为psa指向的为单一对象，因此只会调用一次析构函数，只有一个string对象所管理的内存会被正确释放，因此会造成内存泄漏。当使用delete []时，编译器得知psa指向一个数组，因此会调用三次析构函数，将所有内存都正确释放。\narray new的构造顺序为从低地址到高地址（秩由小到大），array delete的析构顺序为从高地址到低地址（秩由大到小），二者顺序相反。\n\n注：debug和release模式下编译得到的代码以及对象内存分布是有很大差异的，debug模式下保留了很多用于debug的额外代码，占用更多内存（上图中也有所体现）。软件发行使用release版本。\n6.Replacement newplacement new的作用，在指针指定的位置调用构造函数，用新对象覆盖掉原对象，并不重新申请内存。没有所谓的placement delete与之特殊对应，正确使用delete或array delete即可。\n基本使用语法如下：\n#include &lt;new&gt;\nchar* buf &#x3D; new char[sizeof(Complex) * 3];\nComplex* pc &#x3D; new(buf) Complex(1, 2);\ndelete [] buf;\n\n编译器会将placemen new那一行转换为如下操作：\nComplex* pc;\ntry &#123;\n\tvoid* mem &#x3D; operator new(sizeof(Complex), buf); &#x2F;&#x2F;allocate\n\tpc &#x3D; static_cast&lt;Complex*&gt;(mem); &#x2F;&#x2F;cast\n\tpc-&gt;Complex::Complex(1, 2); &#x2F;&#x2F;construct\n&#125;\ncatch( std::bad_alloc ) &#123;\n\t&#x2F;&#x2F;若allocation失败就不执行constructor\n&#125;\n\n这里调用了双参数的operator new，不会申请新的内存，源码如下：\nvoid* operator new(size_t, void* loc) \n&#123; return loc; &#125;\n\n7.重载首先来看C++应用程序分配内存的途径，从而确定我们重载的是哪个环节：\n\n该图中有以下几个关键点：\n\nexpression是不可改变，不可重载的（初学者会误认为重载new、delete是重载的这里，但其实不是）\n重载是重载operator new&#x2F;delete，一般重载类内的operator new（Foo::operator new(…),会被默认声明为static成员函数）。也可重载全局::operator new，但几乎不这样做。\n图中右上角给出了一种重载new的场景：我们希望一次申请一大块内存，自行切割成小块内存作为每个对象，这样可以节省cookie占用的空间。\n后续会有更多关于std::allocator的内容，现代内存管理方式。\n\n\n从图上实例我们可以很清楚地看出重载接管了内存分配的哪个环节。重载operator new[]&#x2F;delete[]和上述过程一致，不再赘述。\n8.重载示例（operator new）\n\n值得关注的点：\n\n以不含虚函数的输出为例，单个对象size为12（string的大小依赖于编译器的实现，不同实现下，大小不一样），5个对象构成的数组size为5*12 + 4 &#x3D; 64，应该是在32位系统下的结果。\n\n若想使用全局操作符(几乎没有人这么做），需要标明作用域，如下：\nFoo* p &#x3D; ::new Foo(7);\n::delete p;\n\nFoo* pArray &#x3D; ::new Foo[5];\n::delete [] pArray;","slug":"C++new内存管理","date":"2022-10-15T16:13:20.000Z","categories_index":"C++","tags_index":"C++","author_index":"月下叶子"},{"id":"7300152523883e0845d647300bd22677","title":"面向对象设计原则","content":"面向对象设计原则1.依赖倒置原则（DIP）\n\n高层模块（稳定）不应该依赖低层模块（变化），二者都应该依赖于抽象（稳定）。\n抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。\n\n2.开放封闭原则（OCP）\n\n对扩展开放，对更改封闭。\n类模块应该是可扩展，但是不可修改。\n\n3.单一职责原则（SRP）\n\n一个类应该仅有一个引起它变化的原因。\n变化的方向隐含着类的责任。\n\n4.Liskov替换原则（LSP）\n\n子类必须能够替换它们的基类。\n继承表达类型抽象。\n\n5.接口隔离原则（ISP）\n\n不应该强迫客户程序依赖它们不用的方法。\n接口应该小而完备。\n\n**6.优先使用对象组合，而不是类继承\n\n类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。\n类继承在某种程度上破坏了封装性，子类父类耦合度高。\n对象组合只要求被破坏的对象具有良好定义的接口，耦合度低。\n\n7.封装变化点\n\n使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响，从而实现层次间的松耦合。\n\n8.针对接口编程，而不是针对实现编程\n\n不将变量类型声明为某个特定的具体类，而是声明为某个接口。（主要指业务类型而非string、vector这些）\n客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。\n客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。\n\n","slug":"设计模式-面向对象设计原则","date":"2022-10-14T16:13:20.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"月下叶子"},{"id":"adf2676e452953c4451f885c2a466f48","title":"设计模式by李建忠","content":"《 设计模式 》by李建忠 - 重点总结模板方法Template Method1.动机Motivation\n\n在软件构建过程中，对于某一项任务，它常常有稳定的整体操作框架，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架和应用之间的关系）而无法和任务的整体结构同时实现。\n如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？\n\n2.代码样例\n2.1 Original Example\n&#x2F;&#x2F;&quot;template1_lib.cpp&quot;\n&#x2F;&#x2F;程序库开发人员\nclass Library &#123;\npublic:\n\tvoid Step1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tvoid Step3() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tvoid Step5() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;&quot;template1_app.cpp&quot;\n&#x2F;&#x2F;应用程序开发人员\nclass Application &#123;\npublic:\n    bool Step2() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n    void Step4() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\nint main() &#123;\n    Library lib();\n    Application app();\n    \n    &#x2F;&#x2F;以某种固定的流程执行任务\n    lib.Step1();\n    \n    if (app.Step2()) &#123;\n        lib.Step3();\n    &#125;\n    \n    for (int i &#x3D; 0; i &lt; 4; i++) &#123;\n        app.Step4();\n    &#125;\n    \n    lib.Step5();\n&#125;\n\n\n结构化软件设计流程\n\n\n\n\n\nLibrary开发人员\nApplication开发人员\n\n\n\n（1）开发1、3、5三个步骤\n（1）开发2、4两个步骤\n\n\n\n（2）程序主流程\n\n\n2.2 Advanced Example\n&#x2F;&#x2F;&quot;template2_lib.cpp&quot;\n&#x2F;&#x2F;程序库开发人员\nclass Library &#123;\npublic:\n    &#x2F;&#x2F;稳定 template method\n    void Run() &#123;\n        Step1();\n        \n        if (Step2()) &#123; &#x2F;&#x2F;支持变化 &#x3D;&#x3D;&gt; 虚函数的多态调用\n            Step3();\n        &#125;\n        \n        for (int i &#x3D; 0; i &lt; 4; i++) &#123;\n            Step4(); &#x2F;&#x2F;支持变化 &#x3D;&#x3D;&gt; 虚函数的多态调用\n        &#125;\n        \n        Step5();\n    &#125;\n    \n    virtual ~Library() &#123; &#125;\n    \nprotected:\n    void Step1() &#123; &#x2F;&#x2F;稳定\n        &#x2F;&#x2F;...\n    &#125;\n    void Step3() &#123; &#x2F;&#x2F;稳定\n    \t&#x2F;&#x2F;...\n    &#125;\n    void Step5() &#123; &#x2F;&#x2F;稳定\n        &#x2F;&#x2F;...\n    &#125;\n    \n    virtual bool Step2() &#x3D; 0; &#x2F;&#x2F;变化\n    virtual void Step4() &#x3D; 0; &#x2F;&#x2F;变化\n&#125;;\n&#x2F;&#x2F;&quot;template2_app.cpp&quot;\n&#x2F;&#x2F;应用程序开发人员\nclass Application : public Library &#123;\nprotected:\n    virtual bool Step2() &#123;\n        &#x2F;&#x2F;... 子类重写实现\n    &#125;\n    virtual void Step4() &#123;\n        &#x2F;&#x2F;... 子类重写实现\n    &#125;\n&#125;;\n\n\nint main() &#123;\n    Library* pLib &#x3D; new Application();\n    lib-&gt;Run();\n    \n    delete pLib;\n&#125;\n\n\n面向对象软件设计流程\n\n\n\n\n\nLibrary开发人员\nApplication开发人员\n\n\n\n（1）开发1、3、5三个步骤\n（1）开发2、4两个步骤\n\n\n（2）程序主流程\n\n\n\n3.Template Method定义\n定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类。Template Method使得子类可以不改变（复用）一个算法的结构即可重定义（override重写）该算法的某些特定步骤。\n4.类图\n\n模板方法Template Method1.动机Motivation\n\n在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。\n如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？\n\n2.代码样例\n2.1Original Example\n&#x2F;&#x2F;&quot;strategy1.cpp&quot;\nenum TaxBase &#123;\n    CN_Tax;\n    US_Tax;\n    DE_Tax;\n    FR_Tax; &#x2F;&#x2F;添加需求，更改\n&#125;;\n\nclass SalesOrder &#123;\n    TaxBase tax;\npublic:\n    double CalculateTax() &#123;\n        &#x2F;&#x2F;...\n        if (tax &#x3D;&#x3D; CN_Tax) &#123;\n            &#x2F;&#x2F;CN************\n        &#125;\n        else if (tax &#x3D;&#x3D; US_Tax) &#123;\n            &#x2F;&#x2F;US************\n        &#125;\n        else if (tax &#x3D;&#x3D; DE_Tax) &#123;\n            &#x2F;&#x2F;DE************\n        &#125;\n        else if (tax &#x3D;&#x3D; FR_Tax) &#123; &#x2F;&#x2F;跟随需求更改..................违背了开闭原则（开放扩展，封闭修改）\n            &#x2F;&#x2F;FR************\n        &#125;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;;\n\n2.2Advanced Example\n&#x2F;&#x2F;&quot;strategy2.cpp&quot;\nclass TaxStrategy &#123;\npublic:\n    virtual double CalculateTex(const Context&amp; context) &#x3D; 0;\n    virtual ~TaxStrategy() &#123; &#125;\n&#125;;\n\nclass CNTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass USTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass DETax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\n&#x2F;***************添加新的国家税费计算需求***************&#x2F;\nclass FRTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass SalesOrder &#123;\nprivate:\n    TaxStrategy* strategy;\npublic:\n    SalesOrder(StrategyFactory* strategyFactory) &#123;\n        this-&gt;strategy &#x3D; strategyFactory-&gt;NewStrategy();\n    &#125;\n    ~SalesOrder() &#123;\n        delete this-&gt;strategy;\n    &#125;\n    \n    double CalculateTax() &#123;\n        &#x2F;&#x2F;...\n        Context context();\n        \n        double val &#x3D; strategy-&gt;CalculateTax(context); &#x2F;&#x2F;多态调用\n        &#x2F;&#x2F;...\n    &#125;\n&#125;;\n3.Strategy策略模式定义\n定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可以独立于使用它的客户程序（稳定）而变化（扩展，子类化）。\n4.类图\n\n5.要点总结\n\nStrategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。\nStrategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句（if-else or switch-case)的代码通常都需要Strategy模式。\n如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。\n\n观察者模式Observer&#x2F;Event1.动机Motivation\n\n在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。\n使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。\n\n","slug":"设计模式","date":"2022-10-14T16:13:20.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"月下叶子"}]