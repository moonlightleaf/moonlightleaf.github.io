{"title":"new内存管理","uid":"9f557fa332d329d3a527e81492ff3945","slug":"C++new内存管理","date":"2022-10-15T16:13:20.000Z","updated":"2023-09-28T12:10:19.504Z","comments":true,"path":"api/articles/C++new内存管理.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++内存管理机制/View.1wlouym8jmn4.jpg","content":"<!-- toc -->\n\n<h2 id=\"1-Overview\"><a href=\"#1-Overview\" class=\"headerlink\" title=\"1.Overview\"></a>1.Overview</h2><p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/1.3v7fuphqxrc0.jpg\"></p>\n<h2 id=\"2-C-Memory-Primitives\"><a href=\"#2-C-Memory-Primitives\" class=\"headerlink\" title=\"2.C++ Memory Primitives\"></a>2.C++ Memory Primitives</h2><table>\n<thead>\n<tr>\n<th align=\"left\">分配</th>\n<th align=\"left\">释放</th>\n<th align=\"left\">类属</th>\n<th align=\"left\">可否重载</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">malloc()</td>\n<td align=\"left\">free()</td>\n<td align=\"left\">C函数</td>\n<td align=\"left\">不可</td>\n</tr>\n<tr>\n<td align=\"left\">new</td>\n<td align=\"left\">delete</td>\n<td align=\"left\">C++表达式（expressions）</td>\n<td align=\"left\">不可</td>\n</tr>\n<tr>\n<td align=\"left\">::operator new()</td>\n<td align=\"left\">::operator delete()</td>\n<td align=\"left\">C++函数</td>\n<td align=\"left\">可</td>\n</tr>\n<tr>\n<td align=\"left\">allocate<T>::allocate()</td>\n<td align=\"left\">allocate<T>::deallocate()</td>\n<td align=\"left\">C++标准库</td>\n<td align=\"left\">可自由设计并以之搭配容器</td>\n</tr>\n</tbody></table>\n<p>注：对于new，还有一种<strong>placement new</strong>操作，语法为 new(ptr) Constructor(…)，该操作<strong>不会申请内存</strong>，而是在已经申请好的内存上（ptr即为内存起始位置）调用指定类型的构造函数。该操作即可操作堆上内存，也可操作栈上内存，后续会有针对placement new更详细的讲解。（placement new的其中一种用法，是搭配array new使用，因为array new时，只能调用默认构造函数，想调用别的构造函数必须在array new之后，在指定位置调用placement new来替换原来的默认构造对象。）</p>\n<h2 id=\"3-四个层面的基本用法\"><a href=\"#3-四个层面的基本用法\" class=\"headerlink\" title=\"3.四个层面的基本用法\"></a>3.四个层面的基本用法</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void* p1 &#x3D; malloc(512); &#x2F;&#x2F;512 bytes\nfree(p1);\n\ncomplex&lt;int&gt;* p2 &#x3D; new complex&lt;int&gt;; &#x2F;&#x2F;one object\ndelete p2;\n\nvoid* p3 &#x3D; ::operator new(512); &#x2F;&#x2F;512 bytes\n::operator delete p3;\n\n&#x2F;&#x2F;以C++20 GCC为例\nint* p4 &#x3D; allocator&lt;int&gt;().allocate(5); &#x2F;&#x2F;分配 5个ints所需内存空间的大小，并尚未构造\nallocator&lt;int&gt;().deallocate(p4, 5);</code></pre>\n\n<p>前三种操作语法始终如一，但allocator<T>的成员函数接口在不同版本的c++标准和编译器下有所不统一，使用时需注意（以下摘自cpp reference）：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; std::allocator&lt;T&gt;::allocate\npointer allocate( size_type n, const void * hint &#x3D; 0 ); &#x2F;&#x2F;(until C++17)\nT* allocate( std::size_t n, const void * hint); &#x2F;&#x2F;(since C++17)(deprecated)(removed in C++20)\nT* allocate( std::size_t n ); &#x2F;&#x2F;(since C++17)(until C++20)\n[[nodiscard]] constexpr T* allocate( std::size_t n ); &#x2F;&#x2F;(since C++20)\n&#x2F;*parameters\nn\t-\tthe number of objects to allocate storage for\nhint\t-\tpointer to a nearby memory location*&#x2F;</code></pre>\n\n<h2 id=\"4-new-delete-expression\"><a href=\"#4-new-delete-expression\" class=\"headerlink\" title=\"4.new&#x2F;delete expression\"></a>4.new&#x2F;delete expression</h2><ul>\n<li>对于<strong>new expression</strong>（第3条中p2的获取方式），实际主要执行<strong>两步操作</strong>：首先使用operator new（第3条中p3的获取方式）申请相应大小的内存，然后在该内存位置上调用指定类型的构造函数（constructor，缩写为ctor），将new的参数列表传递给构造函数。</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Complex* pc &#x3D; new Complex(1, 2);\n&#x2F;&#x2F;编译器将上述代码转为如下操作：\nComplex* pc;\ntry &#123;\n\tvoid* mem &#x3D; operator new(sizeof(Complex));\n\tpc &#x3D; static_cast&lt;Complex*&gt;(mem);\n\tpc-&gt;Complex(1, 2); &#x2F;&#x2F;只有编译器才可以用此方式调用构造函数，同义替换可运用placement new : new(pc) Complex(1, 2),借此调用ctor\n&#125;\ncatch (std::bad_alloc) &#123;\n\t&#x2F;&#x2F;若allocation失败则不执行constructor\n&#125;</code></pre>\n\n<ul>\n<li>对于<strong>operator new</strong>，其行为由如下代码描述。可以看到operator new的内存申请分配操作其实就是由malloc来执行的，但operator new提供了更多的操作可能性。_callnewh是用户可以设定的函数，当malloc申请内存失败时，通过调用用户自定义_callnewh函数，允许我们在malloc失败时固定地执行一些我们想要执行的操作（比如内存已耗尽或碎片化导致无足够的连续内存，可以释放掉某些可以释放的内存，从而使得malloc成功），后续对此部分有更详细的讲解。</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void* operator new(size_t size) noexcept\n&#123;&#x2F;&#x2F;try to allocate size bytes\n\tvoid* p;\n\twhile ((p &#x3D; malloc(size)) &#x3D;&#x3D; 0) &#x2F;&#x2F;malloc返回0表示内存分配失败\n\t&#123;&#x2F;&#x2F;buy more memory or return null pointer\n\t\t_TRY_BEGIN\n\t\t\tif (_callnewh(size) &#x3D;&#x3D; 0) break;\n\t\t_CATCH(std::bad_alloc) return (0);\n\t\t_CATCH_END\n\t&#125;\n\treturn (p);\n&#125;</code></pre>\n\n<ul>\n<li>对于<strong>delete expression</strong>，与new expression镜像类似，实际主要执行<strong>两步操作</strong>：首先调用指针指向对象的析构函数，然后释放指针指向对象所占用的内存。其代码描述如下：</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Complex* pc &#x3D; new Complex(1, 2);\ndelete pc;\n&#x2F;&#x2F;编译器将上述delete pc转为如下操作：\npc-&gt;~Complex(); &#x2F;&#x2F;先析构\noperator delete(pc); &#x2F;&#x2F;然后释放内存</code></pre>\n\n<ul>\n<li>对于<strong>operator delete</strong>，某老版本代码中作如下描述（新版本本质是一样的）。对operator new镜像对称，operator delete释放内存的操作是由<strong>free</strong>来执行的。</li>\n</ul>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void __cdecl operator delete(void* p) _THROW0()\n&#123; &#x2F;&#x2F;free an allocated object\n\tfree(p);\n&#125;</code></pre>\n\n<ul>\n<li><strong>Constructor</strong> &amp; <strong>Destructor</strong> 直接调用：Ctor的直接调用依赖具体编译器的实现，在VC6下通过，在GCC下不通过，因此要避免这种写法，可用placement new来达到同样的目的；Dtor可直接调用，各编译器下都支持。</li>\n</ul>\n<h2 id=\"5-array-new-array-delete\"><a href=\"#5-array-new-array-delete\" class=\"headerlink\" title=\"5.array new, array delete\"></a>5.array new, array delete</h2><p>首先抛出一个问题：我们知道，在语法层面上，new出来一个数组，一定要使用delete []来释放内存。但假如释放时不小心只使用了delete而不是delete []，一定会发生内存泄漏吗？</p>\n<p>来看当正常操作时，我们做了些什么：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Complex* pca &#x3D; new Complex[3];\n&#x2F;&#x2F;唤起三次ctor\n&#x2F;&#x2F;无法借由参数给予初值\ndelete[] pca; &#x2F;&#x2F;唤起3次dtor</code></pre>\n\n<p>使用array new，创建了含有三个Complex object的数组，其在内存中的分布情况见下图：</p>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/5.y4252cdqyxc.jpg\"></p>\n<p>可见，在使用array new的时候，除了三个对象外，还附带有一个cookie，这个cookie记录了一些东西，其中最重要的信息就是整块儿内存的长度。这是因为在使用delete[]时，最底层的内存回收依旧是由free完成的，而free若想调用，必须传给它正确的参数，即将要收回内存的大小，通过使用cookie中记录的内存块大小信息，才能正确的回收内存。这种new&amp;delete的cookie机制，在所有编译器下是统一的。当使用delete时，编译器会认为从pca开始的3<em>sizeof(Complex)大小的内存是<strong>一个对象</strong>，<strong>调用一次析构函数</strong>（至于调用的是最上层object的dtor还是最下层的，后续有分析），将3</em>sizeof(Complex)大小的内存free掉。由此可见，是否发生内存泄漏的决定性因素并不在数组中对象所占用的内存本身，因为无论使用delete还是delete[]，该数组本身所占用的内存都会被正确的释放掉。内存泄漏的真正的根因在于<strong>调用析构函数的次数</strong>。</p>\n<p>没有对每个object调用dtor，有什么影响？对class without pointer member来说<strong>可能没有影响</strong>，对class with pointer member来说<strong>通常有影响</strong>。以动态内存管理类，如std::string（真名basic_string，用了typedef basic_string string或using string &#x3D; basic_string这样的语法）为例，每个string对象管理一个char*指针，该指针指向一块存有真正字符串的内存。当使用如下代码创建string数组并释放时，内存模型如图所示：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">string* psa &#x3D; new sting[3];\ndelete psa; &#x2F;&#x2F;错误示例</code></pre>\n\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-(5).gunigmi6aig.png\"></p>\n<p>使用delete时，str1、str2和str3所占用的内存都会被释放干净，内存泄漏并没有发生在string对象本身所占用的内存上。但因为使用的是delete而非array delete，会使得编译器误以为psa指向的为单一对象，因此只会<strong>调用一次析构函数</strong>，只有一个string对象所管理的内存会被正确释放，因此会造成内存泄漏。当使用delete []时，编译器得知psa指向一个数组，因此会<strong>调用三次析构函数</strong>，将所有内存都正确释放。</p>\n<p>array new的构造顺序为从低地址到高地址（<strong>秩由小到大</strong>），array delete的析构顺序为从高地址到低地址（<strong>秩由大到小</strong>），二者顺序相反。</p>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720221017221243.8n5usy73bfk.png\"></p>\n<p>注：debug和release模式下编译得到的代码以及对象内存分布是有很大差异的，debug模式下保留了很多用于debug的额外代码，占用更多内存（上图中也有所体现）。软件发行使用release版本。</p>\n<h2 id=\"6-Replacement-new\"><a href=\"#6-Replacement-new\" class=\"headerlink\" title=\"6.Replacement new\"></a>6.Replacement new</h2><p><code>placement new的作用，在指针指定的位置调用构造函数，用新对象覆盖掉原对象，并不重新申请内存。没有所谓的placement delete与之特殊对应，正确使用delete或array delete即可。</code></p>\n<p>基本使用语法如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;new&gt;\nchar* buf &#x3D; new char[sizeof(Complex) * 3];\nComplex* pc &#x3D; new(buf) Complex(1, 2);\ndelete [] buf;</code></pre>\n\n<p>编译器会将placemen new那一行转换为如下操作：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Complex* pc;\ntry &#123;\n\tvoid* mem &#x3D; operator new(sizeof(Complex), buf); &#x2F;&#x2F;allocate\n\tpc &#x3D; static_cast&lt;Complex*&gt;(mem); &#x2F;&#x2F;cast\n\tpc-&gt;Complex::Complex(1, 2); &#x2F;&#x2F;construct\n&#125;\ncatch( std::bad_alloc ) &#123;\n\t&#x2F;&#x2F;若allocation失败就不执行constructor\n&#125;</code></pre>\n\n<p>这里调用了双参数的operator new，不会申请新的内存，源码如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void* operator new(size_t, void* loc) \n&#123; return loc; &#125;</code></pre>\n\n<h2 id=\"7-重载\"><a href=\"#7-重载\" class=\"headerlink\" title=\"7.重载\"></a>7.重载</h2><p>首先来看C++应用程序分配内存的途径，从而确定我们重载的是哪个环节：</p>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720221018132205.4s36ab4d9140.png\"></p>\n<p>该图中有以下几个关键点：</p>\n<ul>\n<li>expression是不可改变，不可重载的（初学者会误认为重载new、delete是重载的这里，但其实不是）</li>\n<li>重载是重载operator new&#x2F;delete，一般重载类内的operator new（Foo::operator new(…),会被默认声明为<strong>static</strong>成员函数）。也可重载全局::operator new，但几乎不这样做。</li>\n<li>图中右上角给出了一种重载new的场景：我们希望一次申请一大块内存，自行切割成小块内存作为每个对象，这样可以节省cookie占用的空间。</li>\n<li>后续会有更多关于std::allocator的内容，现代内存管理方式。</li>\n</ul>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720221018135105.5rvrtv56yb00.png\"></p>\n<p>从图上实例我们可以很清楚地看出重载接管了内存分配的哪个环节。重载operator new[]&#x2F;delete[]和上述过程一致，不再赘述。</p>\n<h2 id=\"8-重载示例（operator-new）\"><a href=\"#8-重载示例（operator-new）\" class=\"headerlink\" title=\"8.重载示例（operator new）\"></a>8.重载示例（operator new）</h2><p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720221018141100.33ie6fqz2lw0.png\"></p>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/QQ%E5%9B%BE%E7%89%8720221018141736.36vb2pvb3qg0.png\"></p>\n<p>值得关注的点：</p>\n<ul>\n<li>以不含虚函数的输出为例，单个对象size为12（string的大小依赖于编译器的实现，不同实现下，大小不一样），5个对象构成的数组size为5*12 + 4 &#x3D; 64，应该是在32位系统下的结果。</li>\n</ul>\n<p>若想使用全局操作符(几乎没有人这么做），需要标明作用域，如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Foo* p &#x3D; ::new Foo(7);\n::delete p;\n\nFoo* pArray &#x3D; ::new Foo[5];\n::delete [] pArray;</code></pre>","feature":true,"text":" 1.Overview 2.C++ Memory Primitives 分配 释放 类属 可否重载 malloc() free() C函数 不可 new del...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"C++","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":2,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Overview\"><span class=\"toc-text\">1.Overview</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-C-Memory-Primitives\"><span class=\"toc-text\">2.C++ Memory Primitives</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%9B%9B%E4%B8%AA%E5%B1%82%E9%9D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">3.四个层面的基本用法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-new-delete-expression\"><span class=\"toc-text\">4.new&#x2F;delete expression</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-array-new-array-delete\"><span class=\"toc-text\">5.array new, array delete</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Replacement-new\"><span class=\"toc-text\">6.Replacement new</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">7.重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E9%87%8D%E8%BD%BD%E7%A4%BA%E4%BE%8B%EF%BC%88operator-new%EF%BC%89\"><span class=\"toc-text\">8.重载示例（operator new）</span></a></li></ol>","author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++ design patter:CRTP-以std::enable_shared_from_this为例","uid":"709c36718b9c8207faef8555d07308b6","slug":"C++CRTP","date":"2022-10-27T04:59:20.000Z","updated":"2023-10-27T06:59:58.695Z","comments":true,"path":"api/articles/C++CRTP.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++内存管理机制/View.1wlouym8jmn4.jpg","text":" CRTP简介CRTP，curiously recurring template patter，奇异递归模板模式，是一种C++的设计模式，将继承和模板结合在了一...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"C++","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":2,"path":"api/tags/C.json"}],"author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"feature":true},"next_post":{"title":"面向对象设计原则","uid":"7300152523883e0845d647300bd22677","slug":"设计模式-面向对象设计原则","date":"2022-10-14T16:13:20.000Z","updated":"2023-09-28T12:10:19.497Z","comments":true,"path":"api/articles/设计模式-面向对象设计原则.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/设计模式/9b8cc7_42_Destination1_4k.44dam11au5m0.jpg","text":"面向对象设计原则1.依赖倒置原则（DIP） 高层模块（稳定）不应该依赖低层模块（变化），二者都应该依赖于抽象（稳定）。 抽象（稳定）不应该依赖于实现细节（变化）...","link":"","photos":[],"count_time":{"symbolsCount":601,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"feature":true}}