{"title":"C++ design patter:CRTP-以std::enable_shared_from_this为例","uid":"709c36718b9c8207faef8555d07308b6","slug":"C++CRTP","date":"2022-10-27T04:59:20.000Z","updated":"2023-10-27T06:59:58.695Z","comments":true,"path":"api/articles/C++CRTP.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++内存管理机制/View.1wlouym8jmn4.jpg","content":"<!-- toc -->\n\n<h2 id=\"CRTP简介\"><a href=\"#CRTP简介\" class=\"headerlink\" title=\"CRTP简介\"></a>CRTP简介</h2><p><strong>CRTP</strong>，curiously recurring template patter，奇异递归模板模式，是一种C++的设计模式，将继承和模板结合在了一起，可以实现静态多态、给类提供额外功能等。</p>\n<h2 id=\"CRTP示例\"><a href=\"#CRTP示例\" class=\"headerlink\" title=\"CRTP示例\"></a>CRTP示例</h2><p>cppreference上给出了最简单的示例：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;iostream&gt;\n\ntemplate &lt;class Derived&gt;\nstruct Base &#123;\n\tvoid name() &#123;\n\t\t(static_cast&lt;Derived*&gt;(this))-&gt;impl();\n\t&#125;\n&#125;;\n\nstruct D1 : public Base&lt;D1&gt; &#123;\n\tvoid impl() &#123;\n\t\tstd::cout &lt;&lt; &quot;D1::impl()\\n&quot;;\n\t&#125;\n&#125;;\nstruct D2 : public Base&lt;D2&gt; &#123;\n\tvoid impl() &#123;\n\t\tstd::cout &lt;&lt; &quot;D2::impl()\\n&quot;;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\tBase&lt;D1&gt; b1; b1.name();\n\tBase&lt;D2&gt; b2; b2.name();\n\n\tD1 d1; d1.name();\n\tD2 d2; d2.name();\n&#125;</code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">D1::impl() # 模板生成成功\nD2::impl() # 模板生成成功\nD1::impl() # 继承成功\nD2::impl() # 继承成功</code></pre>\n\n<p>CRTP模式给D1和D2两个类提供了统一的name函数接口，而各自的内部实现不同，表现出多态。相比于虚函数实现的动态多态，静态多态拥有更高的效率，在编译期即决定了调用对象。CRTP的特征是<code>class D : public Base&lt;D&gt;</code>的形式，字面看起来好像类D继承了自身，因此用curiously recurring来形容。模板派生并不是真正的继承关系，而是让父类能够在编译期感知到子类的存在。</p>\n<h2 id=\"C-实例：std-enable-shared-from-this\"><a href=\"#C-实例：std-enable-shared-from-this\" class=\"headerlink\" title=\"C++实例：std::enable_shared_from_this\"></a>C++实例：std::enable_shared_from_this</h2><p>当需要在类的内部，构造出指向对象自身的shared_ptr时，需要让类继承std::enable_shared_from_this。</p>\n<p>使用示例：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 正确示例\nstruct Good : std::enable_shared_from_this&lt;Good&gt; &#123;\n\tstd::shared_ptr&lt;Good&gt; getPtr() &#123;\n\t\treturn shared_from_this();\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F; 错误使用\nstruct Bad &#123;\n\tstd::shared_ptr&lt;Bad&gt; getPtr() &#123;\n\t\treturn std::shared_ptr&lt;Bad&gt;(this);\n\t&#125;\n&#125;;</code></pre>\n\n<p>由此引出两个问题：</p>\n<ul>\n<li><strong>为什么方案二不行</strong></li>\n</ul>\n<p>见下面这种情况：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">int main() &#123;\n\tstd::shared_ptr&lt;Bad&gt; badPtr1(new Bad());\n\tstd::shared_ptr&lt;Bad&gt; badPtr2 &#x3D; badPtr1-&gt;getPtr();\n&#125;</code></pre>\n\n<p>这种情况下，针对于同一个对象构造出的两个shared_ptr之间是无感知的，它们各自的引用计数都为1，那么析构时Bad对象将会被删除两次，会导致崩溃。</p>\n<ul>\n<li><strong>为什么方案一行</strong></li>\n</ul>\n<p>为了解决构造出的两个shared_ptr之间相互无感知的情况，需要引入weak_ptr来进行协助，引入的方法就是继承std::enable_shared_from_this。</p>\n<p>std::enable_shared_from_this类代码如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">template&lt;typename _Tp&gt;\n    class enable_shared_from_this\n    &#123;\n    protected:\n      constexpr enable_shared_from_this() noexcept &#123; &#125;\n\n      enable_shared_from_this(const enable_shared_from_this&amp;) noexcept &#123; &#125;\n\n      enable_shared_from_this&amp;\n      operator&#x3D;(const enable_shared_from_this&amp;) noexcept\n      &#123; return *this; &#125;\n\n      ~enable_shared_from_this() &#123; &#125;\n\n    public:\n      shared_ptr&lt;_Tp&gt;\n      shared_from_this()\n      &#123; return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); &#125;\n\n      shared_ptr&lt;const _Tp&gt;\n      shared_from_this() const\n      &#123; return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); &#125;\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) &#x2F;&#x2F; c++1z or gnu++11\n#define __cpp_lib_enable_shared_from_this 201603L\n      &#x2F;** @&#123;\n       * Get a &#96;weak_ptr&#96; referring to the object that has &#96;*this&#96; as its base.\n       * @since C++17\n       *&#x2F;\n      weak_ptr&lt;_Tp&gt;\n      weak_from_this() noexcept\n      &#123; return this-&gt;_M_weak_this; &#125;\n\n      weak_ptr&lt;const _Tp&gt;\n      weak_from_this() const noexcept\n      &#123; return this-&gt;_M_weak_this; &#125;\n      &#x2F;&#x2F;&#x2F; @&#125;\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;&gt;&amp; __n) const noexcept\n\t&#123; _M_weak_this._M_assign(__p, __n); &#125;\n\n      &#x2F;&#x2F; Found by ADL when this is an associated class.\n      friend const enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;&gt;&amp;,\n\t\t\t\t     const enable_shared_from_this* __p)\n      &#123; return __p; &#125;\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;\n    &#125;;</code></pre>\n\n<p>抽取出我们关心的部分，代码如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">template&lt;typename _Tp&gt;\n    class enable_shared_from_this\n    &#123;\n    protected:\n\n      enable_shared_from_this(const enable_shared_from_this&amp;) noexcept &#123; &#125;\n      ~enable_shared_from_this() &#123; &#125;\n\n    public:\n      shared_ptr&lt;_Tp&gt;\n      shared_from_this()\n      &#123; return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); &#125;\n\n      shared_ptr&lt;const _Tp&gt;\n      shared_from_this() const\n      &#123; return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); &#125;\n\n    private:\n      mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;\n    &#125;;\n</code></pre>\n\n<p>可以看到，调用shared_from_this()方法，都会返回一个shared_ptr对象，每个shared_ptr对象都是通过同一个weak_ptr构造来的。因为通过weak_ptr构造出的shared_ptr会共享weak_ptr的控制块并对引用计数+1，因此通过同一个weak_ptr构造出的多个shared_ptr之间是互通。</p>\n","feature":true,"text":" CRTP简介CRTP，curiously recurring template patter，奇异递归模板模式，是一种C++的设计模式，将继承和模板结合在了一...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"C++","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":2,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CRTP%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">CRTP简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CRTP%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">CRTP示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E5%AE%9E%E4%BE%8B%EF%BC%9Astd-enable-shared-from-this\"><span class=\"toc-text\">C++实例：std::enable_shared_from_this</span></a></li></ol>","author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"VS项目文件层级管理方案","uid":"f90be0cb91d38e221fc75922bd5a6542","slug":"VS项目文件层级管理方案","date":"2022-10-30T16:13:20.000Z","updated":"2023-09-28T12:10:19.504Z","comments":true,"path":"api/articles/VS项目文件层级管理方案.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/Server配图/微信图片_20221031184222.3fu2m6i2rzi0.jpg","text":" 1.新建项目文件夹，以项目名称来命名例如，新建项目文件夹，命名为“MyServer”。 2.在MyServer文件夹下，创建新的控制台项目“HelloCpp”...","link":"","photos":[],"count_time":{"symbolsCount":706,"symbolsTime":"1 mins."},"categories":[{"name":"VS","slug":"VS","count":2,"path":"api/categories/VS.json"}],"tags":[{"name":"VS","slug":"VS","count":2,"path":"api/tags/VS.json"}],"author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"feature":true},"next_post":{"title":"new内存管理","uid":"9f557fa332d329d3a527e81492ff3945","slug":"C++new内存管理","date":"2022-10-15T16:13:20.000Z","updated":"2023-09-28T12:10:19.504Z","comments":true,"path":"api/articles/C++new内存管理.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/C++内存管理机制/View.1wlouym8jmn4.jpg","text":" 1.Overview 2.C++ Memory Primitives 分配 释放 类属 可否重载 malloc() free() C函数 不可 new del...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"C++","slug":"C","count":2,"path":"api/categories/C.json"}],"tags":[{"name":"C++","slug":"C","count":2,"path":"api/tags/C.json"}],"author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"feature":true}}