{"title":"Mudong-JSON : A JSON parser/generator for C++17","uid":"90ec78617eb28a9e0b2ade25b0bdf6ba","slug":"Mudong-JSON","date":"2023-09-28T12:23:12.000Z","updated":"2023-09-28T12:59:14.115Z","comments":true,"path":"api/articles/Mudong-JSON.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/随笔配图/ab0ce6cbf0a420572888ae5e6437625.6v9r441cuz40.jpg","content":"<h1 id=\"Mudong-JSON-A-JSON-parser-generator-for-C-17\"><a href=\"#Mudong-JSON-A-JSON-parser-generator-for-C-17\" class=\"headerlink\" title=\"Mudong-JSON : A JSON parser&#x2F;generator for C++17\"></a>Mudong-JSON : A JSON parser&#x2F;generator for C++17</h1><p><a href=\"https://github.com/moonlightleaf/mudong-json/actions/workflows/cmake-single-platform.yml\"><img src=\"https://github.com/moonlightleaf/mudong-json/actions/workflows/cmake-single-platform.yml/badge.svg\" alt=\"Actions\"></a></p>\n<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>mudong-json是一款基于C++17开发的header-only JSON解析&#x2F;生成器，采用递归下降的方式进行解析，支持<strong>DOM(Document Object Model)</strong> 和<strong>SAX(Simple API for XML)</strong> 两种API风格:</p>\n<ul>\n<li><strong>DOM</strong>是一种基于树状结构的JSON解析模型。在DOM解析中，整个JSON文件被加载到内存中并表示为一个树状结构的对象模型，JSON中的每个元素都对应一个节点，这些节点可以通过编程接口进行访问、遍历和修改。DOM解析允许应用程序以树状结构的方式直接操作JSON数据，但可能需要更多的内存和计算资源，尤其是对于大型文档。DOM的优点是易于编写代码和操作，特别适用于需要频繁随机访问JSON数据的情况。</li>\n<li><strong>SAX</strong>是一种基于事件的JSON解析模型。在SAX解析中，JSON文档被顺序解析，当解析器遇到特定的JSON元素或事件（如开始标签、结束标签、文本内容等）时，它会触发相应的事件，从而允许应用程序在处理过程中做出响应。SAX解析器一次只解析文档的一部分，因此适用于处理大型JSON文档，因为它不需要将整个文档加载到内存中。SAX的优点是效率高，占用的内存少，但在代码编写上通常需要更多的处理逻辑。</li>\n</ul>\n<p>以如下JSON字符串为例：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;hello&quot;: &quot;world&quot;,\n    &quot;t&quot;: true ,\n    &quot;f&quot;: false,\n    &quot;n&quot;: null,\n    &quot;i&quot;: 123,\n    &quot;pi&quot;: 3.1416,\n    &quot;a&quot;: [1, 2, 3, 4]\n&#125;</code></pre>\n<p>其DOM树构建为：</p>\n<div align=\"center\">\n  <img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/项目记录/DOM树.4de859iosye0.webp\" alt=\"DOM树\">\n  <p>DOM树</p>\n</div>\n\n<p>本项目的开发和测试环境为：Ubuntu 20.04 (WSL2)、gcc 9.4.0 -std&#x3D;c++17、cmake 3.16.3。</p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><p>mudong-json定义有三个核心concept，分别是<strong>ReadStream</strong>、<strong>WriteStream</strong>和<strong>Handler</strong>:</p>\n<ul>\n<li><strong>ReadStream</strong>用于读取字符流，目前实现了<strong>StringReadStream</strong>和<strong>FileReadStream</strong>分别用于从内存和文件中读取字符。</li>\n<li><strong>WriteStream</strong>用于输出字符流，目前实现了<strong>StringWriteStream</strong>和<strong>FileWriteStream</strong>分别用于向内存和文件中输出字符。</li>\n<li><strong>Handler</strong>是解析和生成时，用于事件触发和执行的对象，目前实现了SAX风格的<strong>Writer</strong>用于向<strong>WriteStream</strong>输出字符，以及DOM风格的<strong>Document</strong>用于构建JSON对象的树形存储结构。</li>\n</ul>\n<p>其中，<strong>ReadStream</strong>和<strong>WriteStream</strong>的实现只能为<strong>StringXXX</strong>和<strong>FileXXX</strong>，通过<strong>enable_if_t</strong>进行编译期模板参数类型检查；<strong>Handler</strong>除现有实现外，支持自定义，以进行定制化操作。</p>\n<div align=\"center\">\n  <img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/项目记录/架构UML类图.6tnnqyydlws0.webp\" alt=\"架构UML类图\">\n  <p>架构UML类图</p>\n</div>\n\n<p>关系的核心是<strong>Handler</strong>概念。在SAX一边，<strong>Reader</strong>从流解析JSON并将事件发送到<strong>Handler</strong>。<strong>Writer</strong>实现了<strong>Handler</strong>概念，用于处理相同的事件。在DOM一边，<strong>Document</strong>实现了<strong>Handler</strong>概念，用于通过这些事件来构建DOM。在这个设计，SAX是不依赖于DOM的。甚至<strong>Reader</strong>和<strong>Writer</strong>之间也没有依赖。这提供了连接事件发送器和处理器的灵活性。除此之外，<strong>Value</strong>也是不依赖于SAX的。所以，除了将DOM序列化为JSON之外，用户也可以将其序列化为XML，或者做任何其他事情。</p>\n<h2 id=\"值（Value）\"><a href=\"#值（Value）\" class=\"headerlink\" title=\"值（Value）\"></a>值（Value）</h2><p>mudong-json中自定义了可变类型数据存储类<strong>Value</strong>，其设计类似于QT中的QVariant和C++17中的Variant，json文档中的每一个元素（DOM树状结构上的叶子节点或子树）都可以用<strong>Value</strong>来存储，是DOM API的核心。其内部维护一个union来存储数据并节约存储空间：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">union &#123;\n    bool                b_;\n    int32_t             i32_;\n    int64_t             i64_;\n    double              d_;\n    StringWithRefCount* s_;\n    ArrayWithRefCount*  a_;\n    ObjectWithRefCount* o_;\n&#125;;</code></pre>\n<p>并使用<strong>enum class</strong>定义了<strong>ValueType</strong>来表示当前<strong>Value</strong>的类型，防止命名空间污染：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">enum class ValueType &#123;\n    TYPE_NULL,\n    TYPE_BOOL,\n    TYPE_INT32,\n    TYPE_INT64,\n    TYPE_DOUBLE,\n    TYPE_STRING,\n    TYPE_ARRAY,\n    TYPE_OBJECT\n&#125;;</code></pre>\n<p><strong>Value</strong>内部定义了**isXXX()<strong>、</strong>getXXX()<strong>和</strong>setXXX([args])**，分别用来判断类型、访问成员和修改成员（XXX可为Null、Bool、Int32、Int64、Double、String、Array和Object）。其中getXXX()中对类型断言判断以进行类型检查，若Value本身类型与getXXX()类型不一致，在Debug模式下将因断言失败而崩溃。</p>\n<h2 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h2><h3 id=\"1-读写JSON\"><a href=\"#1-读写JSON\" class=\"headerlink\" title=\"1. 读写JSON\"></a>1. 读写JSON</h3><p>DOM风格API使用示例如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;Document.hpp&gt;\n\n#include &lt;iostream&gt;\n\nint main() &#123;\n    json::Document doc;\n    auto err &#x3D; doc.parse(&quot;&#123;&quot;\n    &quot;    \\&quot;precision\\&quot;: \\&quot;zip\\&quot;,&quot;\n    &quot;    \\&quot;Latitude\\&quot;: 37.766800000000003,&quot;\n    &quot;    \\&quot;Longitude\\&quot;: -122.3959,&quot;\n    &quot;    \\&quot;Address\\&quot;: \\&quot;\\&quot;,&quot;\n    &quot;    \\&quot;City\\&quot;: \\&quot;SAN FRANCISCO\\&quot;,&quot;\n    &quot;    \\&quot;State\\&quot;: \\&quot;CA\\&quot;,&quot;\n    &quot;    \\&quot;Zip\\&quot;: \\&quot;94107\\&quot;,&quot;\n    &quot;    \\&quot;Country\\&quot;: \\&quot;US\\&quot;&quot;\n    &quot;    &#125;&quot;);\n\n    if (err !&#x3D; json::ParseError::PARSE_OK) &#123;\n        std::cerr &lt;&lt; json::parseErrorStr(err) &lt;&lt; std::endl;\n        exit(1);\n    &#125;\n\n    &#x2F;&#x2F;get &quot;Country&quot; field\n    &#x2F;&#x2F;使用operator[](const std::string_view&amp;)必须确保doc树中必须包含&quot;Country&quot;的成员，否则将断言失败\n    json::Value&amp; country &#x3D; doc[&quot;Country&quot;];\n    std::cout &lt;&lt; country.getStringView() &lt;&lt; std::endl;\n    &#x2F;&#x2F;更安全的做法是使用Document.findMember(const std::string_view&amp; key)\n    json::Value::MemberIterator countryIter &#x3D; doc.findMember(&quot;Country&quot;);\n    if (countryIter !&#x3D; doc.endMember()) &#123;\n        std::cout &lt;&lt; countryIter-&gt;value.getStringView() &lt;&lt; std::endl;\n    &#125;\n\n    &#x2F;&#x2F;set &quot;Address&quot;\n    json::Value&amp; addr &#x3D; doc[&quot;Address&quot;];\n    addr.setString(&quot;Block 1, Street 2&quot;);\n    std::cout &lt;&lt; addr.getStringView() &lt;&lt; std::endl;\n&#125;</code></pre>\n<p>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">US\nUS\nBlock 1, Street 2</code></pre>\n<p>Document继承自Value，即Document是一个Value，可以使用<strong>isXXX()<strong>、</strong>getXXX()<strong>和</strong>setXXX([args])<strong>来进行操作和判断。对于</strong>json::ValueType::TYPE_ARRAY</strong>类型的Value，可以使用**operator[](const std::string_view&amp;)<strong>便捷地访问或修改Value的成员，但调用方必须确保想要获取的成员确切存在。倘若不确定，更安全的做法是使用</strong>Document.findMember(const std::string_view&amp; key)<strong>，来根据key查找指向该key所对应value的迭代器，倘若不为</strong>Document.endMember()**则说明存在，并可通过返回的迭代器访问和修改value。对于小型的JSON文档，使用DOM风格的API更加方便和简洁。</p>\n<p>SAX风格API使用示例如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;FileReadStream.hpp&gt;\n#include &lt;FileWriteStream.hpp&gt;\n#include &lt;Writer.hpp&gt;\n#include &lt;Reader.hpp&gt;\n#include &lt;noncopyable.hpp&gt;\n#include &lt;Exception.hpp&gt;\n\n#include &lt;iostream&gt;\n\ntemplate&lt;typename Handler&gt;\nclass AddOne: json::noncopyable &#123;\npublic:\n    bool Null()                &#123; return handler_.Null(); &#125;\n    bool Bool(bool b)          &#123; return handler_.Bool(b); &#125;\n    bool Int32(int32_t i32)    &#123; return handler_.Int32(i32 + 1); &#125; &#x2F;&#x2F; add one\n    bool Int64(int64_t i64)    &#123; return handler_.Int64(i64 + 1); &#125; &#x2F;&#x2F; add one\n    bool Double(double d)      &#123; return handler_.Double(d + 1); &#125;  &#x2F;&#x2F; add one\n    bool String(std::string_view s) &#123; return handler_.String(s); &#125;\n    bool StartObject()         &#123; return handler_.StartObject(); &#125;\n    bool Key(std::string_view s)    &#123; return handler_.Key(s); &#125;\n    bool EndObject()           &#123; return handler_.EndObject(); &#125;\n    bool StartArray()          &#123; return handler_.StartArray(); &#125;\n    bool EndArray()            &#123; return handler_.EndArray(); &#125;\n\n    explicit AddOne(Handler&amp; handler): handler_(handler) &#123; &#125;\n\nprivate:\n    Handler&amp; handler_;\n&#125;;\n\nint main() &#123;\n    json::FileReadStream is(stdin);\n    json::FileWriteStream os(stdout);\n    json::Writer writer(os);\n    AddOne addOne(writer);\n\n    json::ParseError err &#x3D; json::Reader::parse(is, addOne);\n    if (err !&#x3D; json::ParseError::PARSE_OK) &#123;\n        std::cerr &lt;&lt; json::parseErrorStr(err) &lt;&lt; std::endl;\n        exit(1);\n    &#125;\n&#125;</code></pre>\n<p><strong>stdin</strong>输入：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;&quot;s&quot;:&quot;string&quot;, &quot;a&quot;:10, &quot;d&quot;:10.0&#125;</code></pre>\n<p><strong>stdout</strong>输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;&quot;s&quot;:&quot;string&quot;,&quot;a&quot;:11,&quot;d&quot;:11.0&#125;</code></pre>\n<p>本示例中，在<strong>Writer</strong>的基础上实现了新的<strong>Handler AddOne</strong>，将JSON文档中的所有数字加1。自定义<strong>Handler</strong>只需保证和原有<strong>concept</strong>一致即可，拥有相同的接口。将不同功能的<strong>Handler</strong>串联起来，可实现自定义功能。使用SAX风格对JSON进行解析和操作时，无需创建DOM树，每一步通过事件进行触发，处理时内存占用不受JSON文档大小的影响，适用于大型JSON文档的流式处理。</p>\n<h3 id=\"2-生成JSON\"><a href=\"#2-生成JSON\" class=\"headerlink\" title=\"2. 生成JSON\"></a>2. 生成JSON</h3><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &lt;FileWriteStream.hpp&gt;\n#include &lt;Writer.hpp&gt;\n\n#include &lt;iostream&gt;\n\nint main() &#123;\n    json::FileWriteStream os(stdout);\n    json::Writer writer(os);\n\n    writer.StartObject();\n    writer.Key(&quot;B&quot;);\n    writer.StartArray();\n    writer.String(&quot;ByteDance&quot;);\n    writer.String(&quot;BaiDu&quot;);\n    writer.EndArray();\n    writer.Key(&quot;A&quot;);\n    writer.String(&quot;Alibaba&quot;);\n    writer.Key(&quot;T&quot;);\n    writer.String(&quot;Tencent&quot;);\n    writer.EndObject();\n&#125;</code></pre>\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;&quot;B&quot;:[&quot;ByteDance&quot;,&quot;BaiDu&quot;],&quot;A&quot;:&quot;Alibaba&quot;,&quot;T&quot;:&quot;Tencent&quot;&#125;</code></pre>\n<p>创建好<strong>WriteStream</strong>并交由<strong>Handler</strong>后，调用相应接口即可生成JSON文档。</p>\n<h2 id=\"测试-性能\"><a href=\"#测试-性能\" class=\"headerlink\" title=\"测试&amp;&amp;性能\"></a>测试&amp;&amp;性能</h2><p>mudong-json使用<a href=\"https://github.com/google/googletest\">Google Test</a>和<a href=\"https://github.com/google/benchmark\">Google Benchmark</a>进行测试，测试程序见<strong>test</strong>和<strong>bench</strong>目录，测试JSON文件为fastjson提供的真实淘宝网数据。</p>\n<h2 id=\"编译-使用\"><a href=\"#编译-使用\" class=\"headerlink\" title=\"编译&amp;&amp;使用\"></a>编译&amp;&amp;使用</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ git clone https:&#x2F;&#x2F;github.com&#x2F;moonlightleaf&#x2F;mudong-json.git\n$ cd mudong-json\n$ git submodule update --init --recursive\n$ mkdir build &amp;&amp; cd build\n$ cmake [-DCMAKE_BUILD_TESTS&#x3D;1] [-DCMAKE_BUILD_BENCHMARK&#x3D;1] [-DCMAKE_BUILD_EXAMPLES&#x3D;1] ..\n$ make</code></pre>\n<p>可以通过选择是否添加**-DCMAKE_BUILD_TESTS&#x3D;1<strong>、</strong>-DCMAKE_BUILD_BENCHMARK&#x3D;1<strong>、</strong>-DCMAKE_BUILD_EXAMPLES&#x3D;1<strong>选项，来决定是否要对</strong>test<strong>、</strong>bench<strong>和</strong>example<strong>目录下的文件进行编译。mudong-json只包含头文件，在使用时，只需将mudong-json的头文件拷贝至新项目的</strong>include**路径下即可。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/Tencent/rapidjson\">RapidJSON</a>: A fast JSON parser&#x2F;generator for C++ with both SAX&#x2F;DOM style API.</li>\n<li><a href=\"https://github.com/miloyip/json-tutorial\">JSON tutorial</a>: 从零开始的 JSON 库教程.</li>\n</ul>\n","feature":true,"text":"Mudong-JSON : A JSON parser&#x2F;generator for C++17 项目简介mudong-json是一款基于C++17开发...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"项目记录","slug":"项目记录","count":1,"path":"api/categories/项目记录.json"}],"tags":[{"name":"项目记录","slug":"项目记录","count":1,"path":"api/tags/项目记录.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Mudong-JSON-A-JSON-parser-generator-for-C-17\"><span class=\"toc-text\">Mudong-JSON : A JSON parser&#x2F;generator for C++17</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">项目简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">项目架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%80%BC%EF%BC%88Value%EF%BC%89\"><span class=\"toc-text\">值（Value）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">使用示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%AF%BB%E5%86%99JSON\"><span class=\"toc-text\">1. 读写JSON</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%94%9F%E6%88%90JSON\"><span class=\"toc-text\">2. 生成JSON</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95-%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">测试&amp;&amp;性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">编译&amp;&amp;使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"《SQL必知必会5th》学习环境搭建","uid":"f800969b8808a99b4d1f639a37a744e3","slug":"SQL-SQL必知必会学习环境搭建","date":"2023-09-10T07:48:12.000Z","updated":"2023-09-28T12:10:19.504Z","comments":true,"path":"api/articles/SQL-SQL必知必会学习环境搭建.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/随笔配图/206ad3cac8878c9ee58e4d371a504e44ea05941e.31g1xdu88og0.png","text":"学习环境搭建学习SQL过程中难免要多写多练，书中刚好也提供了用来学习的数据库，因此首先进行学习环境的搭建。为方便起见将会使用Docker，需提前安装，教程很多不...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"SQL","slug":"SQL","count":2,"path":"api/categories/SQL.json"}],"tags":[{"name":"SQL","slug":"SQL","count":2,"path":"api/tags/SQL.json"}],"author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"feature":true}}