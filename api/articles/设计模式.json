{"title":"设计模式by李建忠","uid":"adf2676e452953c4451f885c2a466f48","slug":"设计模式","date":"2022-10-14T16:13:20.000Z","updated":"2023-09-28T12:10:19.497Z","comments":true,"path":"api/articles/设计模式.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/设计模式/9b8cc7_42_Destination1_4k.44dam11au5m0.jpg","content":"<h1 id=\"《-设计模式-》by李建忠-重点总结\"><a href=\"#《-设计模式-》by李建忠-重点总结\" class=\"headerlink\" title=\"《 设计模式 》by李建忠 - 重点总结\"></a>《 设计模式 》by李建忠 - 重点总结</h1><h2 id=\"模板方法Template-Method\"><a href=\"#模板方法Template-Method\" class=\"headerlink\" title=\"模板方法Template Method\"></a>模板方法Template Method</h2><p><strong>1.动机Motivation</strong></p>\n<ul>\n<li>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作框架，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架和应用之间的关系）而无法和任务的整体结构同时实现。</li>\n<li>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？</li>\n</ul>\n<p><strong>2.代码样例</strong></p>\n<p>2.1 <em><strong>Original Example</strong></em></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;&quot;template1_lib.cpp&quot;\n&#x2F;&#x2F;程序库开发人员\nclass Library &#123;\npublic:\n\tvoid Step1() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tvoid Step3() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n\tvoid Step5() &#123;\n\t\t&#x2F;&#x2F;...\n\t&#125;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;&quot;template1_app.cpp&quot;\n&#x2F;&#x2F;应用程序开发人员\nclass Application &#123;\npublic:\n    bool Step2() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n    void Step4() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\nint main() &#123;\n    Library lib();\n    Application app();\n    \n    &#x2F;&#x2F;以某种固定的流程执行任务\n    lib.Step1();\n    \n    if (app.Step2()) &#123;\n        lib.Step3();\n    &#125;\n    \n    for (int i &#x3D; 0; i &lt; 4; i++) &#123;\n        app.Step4();\n    &#125;\n    \n    lib.Step5();\n&#125;</code></pre>\n\n<ul>\n<li><strong>结构化软件设计流程</strong></li>\n</ul>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-(2).6uasqsa5ml40.png\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Library开发人员</th>\n<th align=\"left\">Application开发人员</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">（1）开发1、3、5三个步骤</td>\n<td align=\"left\">（1）开发2、4两个步骤</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">（2）程序主流程</td>\n</tr>\n</tbody></table>\n<p>2.2 <em><strong>Advanced Example</strong></em></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;&quot;template2_lib.cpp&quot;\n&#x2F;&#x2F;程序库开发人员\nclass Library &#123;\npublic:\n    &#x2F;&#x2F;稳定 template method\n    void Run() &#123;\n        Step1();\n        \n        if (Step2()) &#123; &#x2F;&#x2F;支持变化 &#x3D;&#x3D;&gt; 虚函数的多态调用\n            Step3();\n        &#125;\n        \n        for (int i &#x3D; 0; i &lt; 4; i++) &#123;\n            Step4(); &#x2F;&#x2F;支持变化 &#x3D;&#x3D;&gt; 虚函数的多态调用\n        &#125;\n        \n        Step5();\n    &#125;\n    \n    virtual ~Library() &#123; &#125;\n    \nprotected:\n    void Step1() &#123; &#x2F;&#x2F;稳定\n        &#x2F;&#x2F;...\n    &#125;\n    void Step3() &#123; &#x2F;&#x2F;稳定\n    \t&#x2F;&#x2F;...\n    &#125;\n    void Step5() &#123; &#x2F;&#x2F;稳定\n        &#x2F;&#x2F;...\n    &#125;\n    \n    virtual bool Step2() &#x3D; 0; &#x2F;&#x2F;变化\n    virtual void Step4() &#x3D; 0; &#x2F;&#x2F;变化\n&#125;;</code></pre>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;&quot;template2_app.cpp&quot;\n&#x2F;&#x2F;应用程序开发人员\nclass Application : public Library &#123;\nprotected:\n    virtual bool Step2() &#123;\n        &#x2F;&#x2F;... 子类重写实现\n    &#125;\n    virtual void Step4() &#123;\n        &#x2F;&#x2F;... 子类重写实现\n    &#125;\n&#125;;\n\n\nint main() &#123;\n    Library* pLib &#x3D; new Application();\n    lib-&gt;Run();\n    \n    delete pLib;\n&#125;</code></pre>\n\n<ul>\n<li><strong>面向对象软件设计流程</strong></li>\n</ul>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-(2).6uasqsa5ml40.png\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Library开发人员</th>\n<th align=\"left\">Application开发人员</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">（1）开发1、3、5三个步骤</td>\n<td align=\"left\">（1）开发2、4两个步骤</td>\n</tr>\n<tr>\n<td align=\"left\">（2）程序主流程</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p><strong>3.Template Method定义</strong></p>\n<p><code>定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类。Template Method使得子类可以不改变（复用）一个算法的结构即可重定义（override重写）该算法的某些特定步骤。</code></p>\n<p><strong>4.类图</strong></p>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-(3).1q1a0ww05fr4.png\"></p>\n<h2 id=\"模板方法Template-Method-1\"><a href=\"#模板方法Template-Method-1\" class=\"headerlink\" title=\"模板方法Template Method\"></a>模板方法Template Method</h2><p><strong>1.动机Motivation</strong></p>\n<ul>\n<li>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。</li>\n<li>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</li>\n</ul>\n<p><strong>2.代码样例</strong></p>\n<p>2.1<em><strong>Original Example</strong></em></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;&quot;strategy1.cpp&quot;\nenum TaxBase &#123;\n    CN_Tax;\n    US_Tax;\n    DE_Tax;\n    FR_Tax; &#x2F;&#x2F;添加需求，更改\n&#125;;\n\nclass SalesOrder &#123;\n    TaxBase tax;\npublic:\n    double CalculateTax() &#123;\n        &#x2F;&#x2F;...\n        if (tax &#x3D;&#x3D; CN_Tax) &#123;\n            &#x2F;&#x2F;CN************\n        &#125;\n        else if (tax &#x3D;&#x3D; US_Tax) &#123;\n            &#x2F;&#x2F;US************\n        &#125;\n        else if (tax &#x3D;&#x3D; DE_Tax) &#123;\n            &#x2F;&#x2F;DE************\n        &#125;\n        else if (tax &#x3D;&#x3D; FR_Tax) &#123; &#x2F;&#x2F;跟随需求更改..................违背了开闭原则（开放扩展，封闭修改）\n            &#x2F;&#x2F;FR************\n        &#125;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;;</code></pre>\n\n<p>2.2<em><strong>Advanced Example</strong></em></p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F;&quot;strategy2.cpp&quot;\nclass TaxStrategy &#123;\npublic:\n    virtual double CalculateTex(const Context&amp; context) &#x3D; 0;\n    virtual ~TaxStrategy() &#123; &#125;\n&#125;;\n\nclass CNTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass USTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass DETax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\n&#x2F;***************添加新的国家税费计算需求***************&#x2F;\nclass FRTax : public TaxStrategy &#123;\npublic:\n    virtual double CalculateTax(const Context&amp; context) &#123;\n        &#x2F;&#x2F;*********\n    &#125;\n&#125;;\n\nclass SalesOrder &#123;\nprivate:\n    TaxStrategy* strategy;\npublic:\n    SalesOrder(StrategyFactory* strategyFactory) &#123;\n        this-&gt;strategy &#x3D; strategyFactory-&gt;NewStrategy();\n    &#125;\n    ~SalesOrder() &#123;\n        delete this-&gt;strategy;\n    &#125;\n    \n    double CalculateTax() &#123;\n        &#x2F;&#x2F;...\n        Context context();\n        \n        double val &#x3D; strategy-&gt;CalculateTax(context); &#x2F;&#x2F;多态调用\n        &#x2F;&#x2F;...\n    &#125;\n&#125;;</code></pre>\n<p><strong>3.Strategy策略模式定义</strong></p>\n<p><code>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可以独立于使用它的客户程序（稳定）而变化（扩展，子类化）。</code></p>\n<p><strong>4.类图</strong></p>\n<p><img src=\"https://cdn.statically.io/gh/moonlightleaf/pics@master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-(4).6678ct2qe3w0.png\"></p>\n<p><strong>5.要点总结</strong></p>\n<ul>\n<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</li>\n<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句（if-else or switch-case)的代码通常都需要Strategy模式。</li>\n<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。</li>\n</ul>\n<h2 id=\"观察者模式Observer-Event\"><a href=\"#观察者模式Observer-Event\" class=\"headerlink\" title=\"观察者模式Observer&#x2F;Event\"></a>观察者模式Observer&#x2F;Event</h2><p><strong>1.动机Motivation</strong></p>\n<ul>\n<li>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</li>\n<li>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</li>\n</ul>\n","feature":true,"text":"《 设计模式 》by李建忠 - 重点总结模板方法Template Method1.动机Motivation 在软件构建过程中，对于某一项任务，它常常有稳定的整体...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E3%80%8Bby%E6%9D%8E%E5%BB%BA%E5%BF%A0-%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">《 设计模式 》by李建忠 - 重点总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95Template-Method\"><span class=\"toc-text\">模板方法Template Method</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95Template-Method-1\"><span class=\"toc-text\">模板方法Template Method</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8FObserver-Event\"><span class=\"toc-text\">观察者模式Observer&#x2F;Event</span></a></li></ol></li></ol>","author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"面向对象设计原则","uid":"7300152523883e0845d647300bd22677","slug":"设计模式-面向对象设计原则","date":"2022-10-14T16:13:20.000Z","updated":"2023-09-28T12:10:19.497Z","comments":true,"path":"api/articles/设计模式-面向对象设计原则.json","keywords":null,"cover":"https://cdn.statically.io/gh/moonlightleaf/pics@master/设计模式/9b8cc7_42_Destination1_4k.44dam11au5m0.jpg","text":"面向对象设计原则1.依赖倒置原则（DIP） 高层模块（稳定）不应该依赖低层模块（变化），二者都应该依赖于抽象（稳定）。 抽象（稳定）不应该依赖于实现细节（变化）...","link":"","photos":[],"count_time":{"symbolsCount":601,"symbolsTime":"1 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"}],"author":{"name":"月下叶子","slug":"blog-author","avatar":"https://cdn.statically.io/gh/moonlightleaf/pics@master/about/博客头像.1rm6v48dfu1s.jpg","link":"/","description":"日月东升西落，未曾负你我","socials":{"github":"https://github.com/moonlightleaf","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/leaf_in_the_moon","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode.cn/u/zhong-v0/"}}}},"feature":true},"next_post":{}}